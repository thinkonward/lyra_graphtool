<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lyra_graphtool.graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lyra_graphtool.graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import pickle
import warnings
from copy import deepcopy
from enum import IntEnum
from random import choices, sample, shuffle
from typing import Dict, Generic, List, TypeVar

import matplotlib.pyplot as plt
import numpy as np
import math

import lyra_graphtool.utils as utils
from lyra_graphtool.edge import Edge
from lyra_graphtool.utils import vertices_array
from lyra_graphtool.worker import Worker_Type
from lyra_graphtool.vertex import Vertex, Vertex_Type

Graph = TypeVar(&#39;Graph&#39;)


class Graph_Type(IntEnum):
    RANDOM = 0
    GRID = 1


# graph object
class Graph(Generic[Graph]):

    def __init__(self, num_vertices, max_x, max_y, site_structures,
                 gr_type=Graph_Type.RANDOM, int_pairs=True):
        
        &#39;&#39;&#39;
        ## Graph object set up graph and vertices for process

            Arguments:

                num_vertices:

                max_x:

                max_y:

                site_structures:

                gr_type: Graph_Type.RANDOM, loaded from Graph_Type(class)

                int_pairs: bool, default=True

            Return:

                None
        &#39;&#39;&#39;

        self.vertices = []
        self.edges = []
        self.graph_type = gr_type
        self.generate_integer_pairs = int_pairs  # locations (x,y) integer pairs?
        self.site_structures = site_structures

        if num_vertices &gt; max_x * max_y:
            raise ValueError(f&#39;Number of vertices ({num_vertices}) must be &lt; max_x * max_y ({max_x}*{max_y})&#39;)

        if gr_type == Graph_Type.RANDOM:

            # make sure generated points are unique
            unique_flag = False
            ctr = 0
            while not unique_flag and ctr &lt; 10000:  # if &gt;10000 tries, do below
                ctr += 1
                if self.generate_integer_pairs:
                    x_rand = choices(range(max_x), k=num_vertices)
                    y_rand = choices(range(max_y), k=num_vertices)
                else:  # generate real-valued x,y
                    x_rand = np.random.uniform(0, max_x, num_vertices)
                    y_rand = np.random.uniform(0, max_y, num_vertices)

                t = [(x_rand[i], y_rand[i]) for i in range(num_vertices)]

                unique = {}
                for p in t:
                    unique[p] = 1

                unique_flag = len(unique) == num_vertices

            # if one could not generate integer pairs, use sample approach
            #
            if not unique_flag:
                sample_space = [[i, j] for i in range(max_x) for j in range(max_y)]
                shuffle(sample_space)
                x_rand = [sample_space[i][0] for i in range(num_vertices)]
                y_rand = [sample_space[i][1] for i in range(num_vertices)]

            for i in range(num_vertices):
                v = Vertex(x_rand[i], y_rand[i], Vertex_Type.BASIC)
                self.vertices.append(v)

        else:  # grid graph

            radius = np.floor(np.sqrt(num_vertices))

            radius = int(min(radius, max_x + 1, max_y + 1))

            # fill up a cube first
            for x in range(radius):
                for y in range(radius):
                    v = Vertex(x, y, Vertex_Type.BASIC)
                    self.vertices.append(v)

            # fill up right side, then top with rest
            remainder = num_vertices - radius ** 2

            for y in range(min(remainder, radius)):
                v = Vertex(radius, y, Vertex_Type.BASIC)
                self.vertices.append(v)

            remainder_horiz = remainder - radius

            if remainder_horiz &gt; 0:
                y = radius
                for offset in range(remainder_horiz):
                    x = radius - offset
                    v = Vertex(x, y, Vertex_Type.BASIC)
                    self.vertices.append(v)

        #
        # set up edges for travel: in_graph() method
        # defined in Edge class
        #
        self.set_edges()

    # return numpy array of vertices v: v = [ [x0,y0], [x1,y1], ... ]
    def vertices_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;
        ## Method to get numpy array of vertices v: v = [ [x0,y0], [x1,y1], ... ]

            Arguments:
                None

            Return:
                np.ndarray, vertices
        &#39;&#39;&#39;
        return vertices_array(self.vertices)

    # get info about vertices: coords and type
    # if no arg passed, get info about all vertices in graph
    def vertices_info(self, vert_list: List = None) -&gt; Dict:
        &#39;&#39;&#39;
        ## Get info about vertices: coordinates and type. If no arg passed, get info about all vertices in graph.

            Arguments:
                vert_list: list, default = None
                    list of vertices to recieve info about

            Return:
                dict, vertice information
        &#39;&#39;&#39;
        info = {}
        if vert_list is None:
            vert_list = self.vertices
        none_ct = 0
        for v in vert_list:
            if v is not None:
                ct = 1
                if (v.x, v.y) in info.keys():
                    ct = info[(v.x, v.y)][1] + 1
                info[(v.x, v.y)] = (v.vertex_type, ct)
            else:  # None
                none_ct += 1

            if none_ct &gt; 0:
                info[&#39;None&#39;] = none_ct

        return info

    # get vertices of specific type
    def get_vertices_type(self, v_type: Vertex_Type) -&gt; List:
        &#39;&#39;&#39;
        ## Get vertices of a specific type

            Arguments:
                v_type: Vertex_Type (Class)

            Return:
                list, vertices of a given type
        &#39;&#39;&#39;
        # make sure type is legitimate
        if v_type not in Vertex_Type:
            types = list(Vertex_Type.__members__)
            raise ValueError(f&#39;vertex type {v_type} is not in vertex_type.{types}&#39;)

        # get vertices of given type
        verts = []
        for v in self.vertices:
            if v.vertex_type == v_type:
                verts.append(v)

        return verts

    # get vertex with specified coordinates (x,y)
    def get_vertex_xy(self, x: float, y: float) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Get vertex with specified coordinates (x,y)

            Arguments:
                x: float, x vertice value

                y: float, y vertice value

            Return:
                Vertex (Class)
        &#39;&#39;&#39;
        for v in self.vertices:
            if v.x == x:
                if v.y == y:
                    return v
        return None

    # set the type of vertex at coords (x,y)
    def set_vertex_type(self, v_type: Vertex_Type, v: Vertex = None, x: float = None, y: float = None) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Set the type of vertex as given coordinates (x,y)

            Arguments:
                v_type: Vertex_Type (Class)

                v: Vertex (class), default = None

                x: float, x vertice value, default = None

                y: float, y vertice value, default = None

            Return:
                Vertex (class)
        &#39;&#39;&#39;

        if v is None:
            if x is None or y is None:
                raise ValueError(&#39;must specify either vertex or (x,y)&#39;)
            else:
                v = Vertex(x, y)

        for i in range(len(self.vertices)):
            if self.vertices[i] == v:
                self.vertices[i].vertex_type = v_type
                return self.vertices[i]

        return None

    # set the type of vertex at coords (x,y)
    def set_vertex_coords(self, v: Vertex, x: float, y: float) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Set the type of vertex as coordinates (x,y)

            Arguments:
                v: Vertex (class)

                x: float, x vertice value

                y: float, y vertice value

            Return:
                list, vertices of a given type
        &#39;&#39;&#39;

        for i in range(len(self.vertices)):
            if self.vertices[i] == v:
                self.vertices[i].x = x
                self.vertices[i].y = y
                return self.vertices[i]

        return None
    
    # set vertex on graph
    def add_vertex(self, v: Vertex):
        
        # check if vertex not in graph already
        for graph_v in self.vertices:
            if graph_v.x == v.x and graph_v.y == v.y:
                raise ValueError(&#34;Vertex already in the graph&#34;)
        
        # set other parameters for vertex
        v.time_to_acquire = self.site_structures.site_acquire_times[v.vertex_type]
        v.reward = self.site_structures.site_rewards[v.vertex_type]
        v.mult_time = self.site_structures.site_mult_time[v.vertex_type]
        v.mult_time_active = self.site_structures.site_mult_time_active[v.vertex_type]
        v.mult_worker = self.site_structures.site_mult_worker[v.vertex_type]
        v.expiration_time = self.site_structures.site_expiration_times[v.vertex_type]
        self.vertices.append(v)
        self.make_graph_connected()
        self.set_edges()
    
    # remove vertex from graph
    def remove_vertex(self, x: float, y: float):
        for i, v in enumerate(self.vertices):
            if v.x == x and v.y == y:
                self.vertices.pop(i)
        self.set_edges()
                
    def _set_site_structures(self):
        for v in self.vertices:
            vt = v.vertex_type
            if vt in v.accessible_types():
                if self.site_structures.site_acquire_times[vt] != utils.NotSpecI:
                    v.time_to_acquire = self.site_structures.site_acquire_times[vt]
                if self.site_structures.site_rewards[vt] != utils.NotSpecF:
                    v.reward = self.site_structures.site_rewards[vt]
                if self.site_structures.site_mult_time[vt] != utils.NotSpecF:
                    v.mult_time = self.site_structures.site_mult_time[vt]
                if self.site_structures.site_mult_time_active[vt] != utils.NotSpecI:
                    v.mult_time_active = self.site_structures.site_mult_time_active[vt]
                if self.site_structures.site_mult_worker[vt] != utils.NotSpecF:
                    v.mult_worker = self.site_structures.site_mult_worker[vt]
                if self.site_structures.site_expiration_times[vt] != utils.NotSpecI:
                    v.expiration_time = self.site_structures.site_expiration_times[vt]

    # closest vertices to specified vertex
    def closest_vertices(self, v: Vertex) -&gt; List:
        # get distances to other vertices
        dist = []
        for v2 in self.vertices:
            d = Edge(v, v2).length
            if d &gt; 0:
                dist.append(d)

        dist_min = min(dist)

        verts_closest = []
        for v2 in self.vertices:
            if Edge(v, v2).length == dist_min:
                verts_closest.append(v2)

        return verts_closest

    # get isolated vertices - those with no nearest neighbor
    # Return: list of deep copies of isolated vertices
    def isolated_vertices(self) -&gt; List:
        isol = []
        for v in self.vertices:
            vc = self.closest_vertices(v)
            if len(vc) &gt; 0:
                if Edge(v, vc[0]).nearest_neighbor():
                    continue
                else:
                    isol.append(v)
            else:
                isol.append(v)

        return isol

    # get adjacent vertices to specified vertex via edges
    def adjacent_vertices(self, v: Vertex) -&gt; List:
        edges_v = self.get_edges_at_vertex(v)

        verts_adj = []
        for e in edges_v:
            v1, v2 = e.v1, e.v2
            if v1 != v:
                verts_adj.append(v1)
            else:
                verts_adj.append(v2)

        return verts_adj

    #
    # set up edges for travel: in_graph() method
    # defined in Edge class
    # Note: this method needs to be called if vertices are changed
    #
    def set_edges(self) -&gt; List:

        self.edges = []  # delete old edge set if there was one
        for v in self.vertices:
            for v2 in self.vertices:
                e = Edge(v, v2)
                if e.in_graph():  # does this edge meet the conditions to be in graph?
                    if e not in self.edges:  # may have (v2,v1) in edges
                        self.edges.append(e)
        return self.edges

    # get list of edges in given list
    # if edge list is not given, get info for all edges in graph
    def edges_info(self, edge_list: List = None) -&gt; List:
        info = {}
        if edge_list is None:
            edge_list = self.edges
        for e in edge_list:
            x1, y1 = e.v1.x, e.v1.y
            x2, y2 = e.v2.x, e.v2.y
            coords = ((x1, y1), (x2, y2))
            ct = 1
            if coords in info.keys():
                ct = info[coords] + 1
            info[((x1, y1), (x2, y2))] = ct

        return info

    # return edges containing specified vertex
    def get_edges_at_vertex(self, v: Vertex) -&gt; List:
        edges = []
        for e in self.edges:
            v1, v2 = e.v1, e.v2
            if v == v1 or v == v2:
                edges.append(e)

        return edges

    # randomly set origin and sites
    def set_random_sites_origin(self, n_site1: int, n_site2: int, n_site3: int) -&gt; None:

        num_sites = n_site1 + n_site2 + n_site3
        num_v = len(self.vertices)

        if num_v &lt; num_sites + 1:
            raise ValueError(f&#39;Not enough vertices on graph: require number vertices ({num_v}) &#39; +
                             f&#39;&gt;= num site 1 ({n_site1}) + num site 2 ({n_site2}) &#39; +
                             f&#39;+ num site 3 ({n_site3})+ 1&#39;
                             )

        index_verts = sample(range(0, num_v), num_sites + 1)  # sites and origin

        # set sites
        for i in index_verts[:n_site1]:
            self.vertices[i].vertex_type = Vertex_Type.SITE1
        for i in index_verts[n_site1: n_site1 + n_site2]:
            self.vertices[i].vertex_type = Vertex_Type.SITE2
        for i in index_verts[-n_site3 - 1: -1]:
            self.vertices[i].vertex_type = Vertex_Type.SITE3

        # set last to origin
        self.vertices[index_verts[-1]].vertex_type = Vertex_Type.ORIGIN
        self._set_site_structures()

    # return edge of minimum distance between two sets of vertices
    # this is the minimum distance of points (v1,v2) v1 in set1, v2 in set2
    @staticmethod
    def distance(vert_list_1: List, vert_list_2: List) -&gt; Edge:

        edges = []
        for v1 in vert_list_1:
            for v2 in vert_list_2:
                edges.append(Edge(v1, v2))

        edge_lens = [e.length for e in edges]

        min_len = min(edge_lens)

        return edges[edge_lens.index(min_len)]

    # depth first search
    def depth_first_search(self, v: Vertex, visited: List) -&gt; List:

        # mark current vertex as visited
        visited.append(v)

        # repeat for all vertices adjacent to v
        for v2 in self.adjacent_vertices(v):

            if v2 not in visited:
                # update the visited list
                visited = self.depth_first_search(v2, visited)

        return visited

    # connected components
    def connected_components(self) -&gt; List:

        visited = []
        cc = []

        for v in self.vertices:

            if v not in visited:
                comp_v = self.depth_first_search(v, [])
                visited += comp_v
                cc.append(comp_v)

        return cc

    # make graph connected by moving connected components in x then y directions
    # towards the largest component until the number of components is reduced
    def make_graph_connected(self) -&gt; None:

        if len(self.vertices) == 1:
            return

        # get largest component as anchor
        cc = self.connected_components()
        cc_len = [len(c) for c in cc]
        ind_max = cc_len.index(max(cc_len))
        anchor_component = cc[ind_max]
        components = cc[:ind_max] + cc[ind_max + 1:]

        while len(components) &gt; 0:

            c0 = components[0]

            # get vertices of min distance
            e_min = self.distance(anchor_component, c0)

            v1, v2 = e_min.v1, e_min.v2

            if v1 in anchor_component:
                va, v0 = v1, v2
            else:
                va, v0 = v2, v1

            # move c0 towards anchor
            sx = np.sign(va.x - v0.x)
            sy = np.sign(va.y - v0.y)

            cl = len(components)

            c0_translate_x = deepcopy(c0)
            ind_v0 = c0_translate_x.index(v0)
            x_diff = sx
            y_diff = sy

            # keep translating until:
            #   - number of connected components decrease, or
            #   - the set we are translating is directly above or below anchor
            #     ie  sx changes to zero (at this point, we&#39;ll translate in y dir)
            while len(components) == cl and x_diff == sx and x_diff != 0:

                # translate x components of c0
                for i in range(len(c0)):
                    c = c0[i]
                    # note  cmin is translated to va + (sx,0)
                    # which is a translation by (vax + sx - v0x)
                    x_new = c.x + sx
                    y_new = c.y
                    self.set_vertex_coords(v=c, x=x_new, y=y_new)  # change graph vert
                    c0_translate_x[i].x, c0_translate_x[i].y = x_new, y_new

                self.set_edges()  # update edges since vertices were changed

                # recompute the number of connected components &amp; anchor
                cc = self.connected_components()
                cc_len = [len(c) for c in cc]
                ind_max = cc_len.index(max(cc_len))
                anchor_component = cc[ind_max]
                components = cc[:ind_max] + cc[ind_max + 1:]

                if len(components) == cl:
                    x0 = c0_translate_x[ind_v0].x
                    x_diff = np.sign(va.x - x0)

            # translate y components of c0_translate_x
            c0_translate_y = deepcopy(c0_translate_x)

            # keep translating until:
            #   - number of connected components decrease, or
            #   - the set we are translating is directly left or right of anchor
            #     ie  sy changes to zero
            while len(components) == cl and y_diff == sy and y_diff != 0:

                for i in range(len(c0_translate_y)):
                    c = c0_translate_y[i]
                    # note  cmin is translated to va + (0,sy)
                    # which is a translation by (vay + sy - v0y)
                    x_new = c.x
                    y_new = c.y + sy
                    self.set_vertex_coords(v=c, x=x_new, y=y_new)
                    c0_translate_y[i].x, c0_translate_y[i].y = x_new, y_new

                self.set_edges()  # update edges since vertices were changed

                # recompute the number of connected components &amp; anchor
                cc = self.connected_components()
                cc_len = [len(c) for c in cc]
                ind_max = cc_len.index(max(cc_len))
                anchor_component = cc[ind_max]
                components = cc[:ind_max] + cc[ind_max + 1:]

                if len(components) == cl:
                    y0 = c0_translate_y[ind_v0].y
                    y_diff = np.sign(va.y - y0)

            if len(components) == cl:
                # neither translation above resulted in the nearest neighboring of sets
                print(&#39;after translations in x and y, no reduction in components&#39;)
                print(&#39;components:&#39;)
                for c in components:
                    print(f&#39;{self.vertices_info(c)}&#39;)
                return

        #
        # make minimum x and y coords of graph zero
        #
        x_coords = [v.x for v in self.vertices]
        y_coords = [v.y for v in self.vertices]

        x_min = min(x_coords)
        y_min = min(y_coords)

        for v in self.vertices:
            v.x = v.x - x_min
            v.y = v.y - y_min

        self.set_edges()  # update edges since vertices were changed

        return

    # graph vertices
    # color vertices in verts_list OTHER color
    def print_graph(self, vert_list: List = None, filename_out=None) -&gt; None:
        color_dict = {
            &#39;BASIC&#39;: &#39;black&#39;,
            &#39;ORIGIN&#39;: &#39;yellow&#39;,
            &#39;SITE1&#39;: &#39;red&#39;,
            &#39;SITE2&#39;: &#39;blue&#39;,
            &#39;SITE3&#39;: &#39;green&#39;
        }

        types = color_dict.keys()

        # plot edges
        for e in self.edges:
            x_values = [e.v1.x, e.v2.x]
            y_values = [e.v1.y, e.v2.y]
            plt.plot(x_values, y_values, linestyle=&#34;--&#34;, color=&#39;black&#39;)

        plots = []
        for t in types:
            verts = self.get_vertices_type(Vertex_Type[t])
            x, y = vertices_array(verts).T
            p = plt.scatter(x, y, color=color_dict[t])
            plots.append(p)

        # color vertices in vert_list orange
        if vert_list is not None:
            x, y = vertices_array(vert_list).T
            plt.scatter(x, y, color=&#39;orange&#39;)

        plt.legend(tuple(plots), tuple(types), scatterpoints=1,
                   bbox_to_anchor=(0.5, -.2),
                   loc=&#39;lower center&#39;,
                   ncol=3,
                   fontsize=8)

        if filename_out is not None:
            plt.savefig(filename_out)

        plt.show()

    # save graph to file
    def save(self, file_name: str) -&gt; None:
        fn = file_name

        with open(fn, &#39;wb&#39;) as f:
            pickle.dump(self, f)

        # get all paths from vertex v1 to vertex v2
        # return: List of lists, each member list being vertices that represent the path
        # Note:
        #  - adjacent vertices in the list are adjacent in the graph - ie compose an edge
        #  - returned paths do not have cycles - each vertex in the path is visited only once
        #  - max_len argument, if set, will limit paths to this maximum length

    def paths(self, v1: Vertex, v2: Vertex, max_len: float = math.inf, visited: List = None, ) -&gt; List:

        if visited is None:
            visited = []

        visited.append(v1)

        adj_list = self.adjacent_vertices(v1)
        vnext_list = [v for v in adj_list if v not in visited]

        if len(vnext_list) == 0 or len(visited) &gt; max_len:  # nothing left
            return [[]]
        else:
            paths_return = []
            # try next possible paths
            for vnext in vnext_list:  # get adj verts not visited

                visited_next = deepcopy(visited)

                if vnext == v2:
                    paths_next = [[v2]]
                else:
                    paths_next = self.paths(vnext, v2, max_len, visited_next)  # get path vnext to end v2

                for p in paths_next:
                    if len(p) &gt; 0:
                        paths_return.append([v1] + p)  # path from start v1 to end v2

            return paths_return

        # save graph data to json

    def save_to_json(self, file_name: str) -&gt; None:
        graph_json = {}
        graph_json[&#39;vertices&#39;] = {}
        for v in self.vertices:  # set up dict
            graph_json[&#39;vertices&#39;][str(v.x)] = {}
        for v in self.vertices:  # set up dict
            graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)] = {}

        for v in self.vertices:
            for k in vars(v).keys():
                if k != &#39;x&#39; and k != &#39;y&#39;:
                    val = getattr(v, k)
                    # print(f&#39;v={(v.x,v.y)}  {k}={k}, type k={type(k)}, val={val}, typev={type(val)}&#39;)
                    graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)][k] = getattr(v, k)

        graph_json[&#39;edges&#39;] = []
        for e in self.edges:
            ej = [e.v1.x, e.v1.y, e.v2.x, e.v2.y]
            ejs = [str(val) for val in ej]
            graph_json[&#39;edges&#39;].append(ejs)

        # save to json
        with open(file_name, &#39;w&#39;) as f:
            json.dump(graph_json, f)

        # load graph data from json

    def load_from_json(self, file_name: str) -&gt; None:
        # dict to convert integer keys to Worker_Type keys
        wt_dict = {}
        lwt = list(Worker_Type.__members__.values())
        for i in range(len(lwt)):
            wt = lwt[i]
            wt_dict[wt.value] = wt

        # dict to convert integer keys to Vertex_Type keys
        vt_dict = {}
        lvt = list(Vertex_Type.__members__.values())
        for i in range(len(lvt)):
            vt = lvt[i]
            vt_dict[vt.value] = vt

        with open(file_name) as f:
            gj = json.load(f)

        vertsj = gj[&#39;vertices&#39;]
        edgesj = gj[&#39;edges&#39;]

        vertices = []
        for xs in vertsj.keys():
            x = float(xs)
            vertsj_x = vertsj[xs]
            for ys in vertsj_x.keys():
                y = float(ys)
                vj = vertsj_x[ys]
                v = Vertex(x, y)

                # set properties
                for k in vj.keys():
                    if k in (&#39;reward&#39;, &#39;mult_time&#39;):
                        setattr(v, k, float(vj[k]))

                    elif k in (&#39;expiration_time&#39;, &#39;time_to_acquire&#39;):
                        if vj[k] is None:
                            val = None
                        else:
                            val = int(vj[k])

                        setattr(v, k, val)

                    elif k == &#39;vertex_type&#39;:
                        setattr(v, k, vt_dict[int(vj[k])])

                    elif k == &#39;mult_worker&#39;:
                        # create Worker_Type keys
                        mult_worker = {}
                        for kwt in vj[k].keys():
                            mult_worker[wt_dict[int(kwt)]] = vj[k][kwt]
                        setattr(v, k, mult_worker)

                    elif k == &#39;mult_time_active&#39;:
                        setattr(v, k, (vj[k][0], vj[k][1]))

                vertices.append(v)

        edges = []
        for ej in edgesj:
            x1, y1 = float(ej[0]), float(ej[1])
            x2, y2 = float(ej[2]), float(ej[3])

            # get v1 and v2
            v1, v2 = None, None
            for v in vertices:
                if v.x == x1 and v.y == y1:
                    v1 = v
                if v.x == x2 and v.y == y2:
                    v2 = v

            if v1 is None:
                raise RuntimeError(f&#39;{(x1, y1)} in json file edges, but not in json file vertices&#39;)
            if v2 is None:
                raise RuntimeError(f&#39;{(x2, y2)} in json file edges, but not in json file vertices&#39;)

            e = Edge(v1, v2)
            edges.append(e)

        self.vertices = vertices  # no errors, set up verts &amp; edges
        self.edges = edges</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lyra_graphtool.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>num_vertices, max_x, max_y, site_structures, gr_type=Graph_Type.RANDOM, int_pairs=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p>
<h2 id="graph-object-set-up-graph-and-vertices-for-process">Graph object set up graph and vertices for process</h2>
<pre><code>Arguments:

    num_vertices:

    max_x:

    max_y:

    site_structures:

    gr_type: Graph_Type.RANDOM, loaded from Graph_Type(class)

    int_pairs: bool, default=True

Return:

    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph(Generic[Graph]):

    def __init__(self, num_vertices, max_x, max_y, site_structures,
                 gr_type=Graph_Type.RANDOM, int_pairs=True):
        
        &#39;&#39;&#39;
        ## Graph object set up graph and vertices for process

            Arguments:

                num_vertices:

                max_x:

                max_y:

                site_structures:

                gr_type: Graph_Type.RANDOM, loaded from Graph_Type(class)

                int_pairs: bool, default=True

            Return:

                None
        &#39;&#39;&#39;

        self.vertices = []
        self.edges = []
        self.graph_type = gr_type
        self.generate_integer_pairs = int_pairs  # locations (x,y) integer pairs?
        self.site_structures = site_structures

        if num_vertices &gt; max_x * max_y:
            raise ValueError(f&#39;Number of vertices ({num_vertices}) must be &lt; max_x * max_y ({max_x}*{max_y})&#39;)

        if gr_type == Graph_Type.RANDOM:

            # make sure generated points are unique
            unique_flag = False
            ctr = 0
            while not unique_flag and ctr &lt; 10000:  # if &gt;10000 tries, do below
                ctr += 1
                if self.generate_integer_pairs:
                    x_rand = choices(range(max_x), k=num_vertices)
                    y_rand = choices(range(max_y), k=num_vertices)
                else:  # generate real-valued x,y
                    x_rand = np.random.uniform(0, max_x, num_vertices)
                    y_rand = np.random.uniform(0, max_y, num_vertices)

                t = [(x_rand[i], y_rand[i]) for i in range(num_vertices)]

                unique = {}
                for p in t:
                    unique[p] = 1

                unique_flag = len(unique) == num_vertices

            # if one could not generate integer pairs, use sample approach
            #
            if not unique_flag:
                sample_space = [[i, j] for i in range(max_x) for j in range(max_y)]
                shuffle(sample_space)
                x_rand = [sample_space[i][0] for i in range(num_vertices)]
                y_rand = [sample_space[i][1] for i in range(num_vertices)]

            for i in range(num_vertices):
                v = Vertex(x_rand[i], y_rand[i], Vertex_Type.BASIC)
                self.vertices.append(v)

        else:  # grid graph

            radius = np.floor(np.sqrt(num_vertices))

            radius = int(min(radius, max_x + 1, max_y + 1))

            # fill up a cube first
            for x in range(radius):
                for y in range(radius):
                    v = Vertex(x, y, Vertex_Type.BASIC)
                    self.vertices.append(v)

            # fill up right side, then top with rest
            remainder = num_vertices - radius ** 2

            for y in range(min(remainder, radius)):
                v = Vertex(radius, y, Vertex_Type.BASIC)
                self.vertices.append(v)

            remainder_horiz = remainder - radius

            if remainder_horiz &gt; 0:
                y = radius
                for offset in range(remainder_horiz):
                    x = radius - offset
                    v = Vertex(x, y, Vertex_Type.BASIC)
                    self.vertices.append(v)

        #
        # set up edges for travel: in_graph() method
        # defined in Edge class
        #
        self.set_edges()

    # return numpy array of vertices v: v = [ [x0,y0], [x1,y1], ... ]
    def vertices_array(self) -&gt; np.ndarray:
        &#39;&#39;&#39;
        ## Method to get numpy array of vertices v: v = [ [x0,y0], [x1,y1], ... ]

            Arguments:
                None

            Return:
                np.ndarray, vertices
        &#39;&#39;&#39;
        return vertices_array(self.vertices)

    # get info about vertices: coords and type
    # if no arg passed, get info about all vertices in graph
    def vertices_info(self, vert_list: List = None) -&gt; Dict:
        &#39;&#39;&#39;
        ## Get info about vertices: coordinates and type. If no arg passed, get info about all vertices in graph.

            Arguments:
                vert_list: list, default = None
                    list of vertices to recieve info about

            Return:
                dict, vertice information
        &#39;&#39;&#39;
        info = {}
        if vert_list is None:
            vert_list = self.vertices
        none_ct = 0
        for v in vert_list:
            if v is not None:
                ct = 1
                if (v.x, v.y) in info.keys():
                    ct = info[(v.x, v.y)][1] + 1
                info[(v.x, v.y)] = (v.vertex_type, ct)
            else:  # None
                none_ct += 1

            if none_ct &gt; 0:
                info[&#39;None&#39;] = none_ct

        return info

    # get vertices of specific type
    def get_vertices_type(self, v_type: Vertex_Type) -&gt; List:
        &#39;&#39;&#39;
        ## Get vertices of a specific type

            Arguments:
                v_type: Vertex_Type (Class)

            Return:
                list, vertices of a given type
        &#39;&#39;&#39;
        # make sure type is legitimate
        if v_type not in Vertex_Type:
            types = list(Vertex_Type.__members__)
            raise ValueError(f&#39;vertex type {v_type} is not in vertex_type.{types}&#39;)

        # get vertices of given type
        verts = []
        for v in self.vertices:
            if v.vertex_type == v_type:
                verts.append(v)

        return verts

    # get vertex with specified coordinates (x,y)
    def get_vertex_xy(self, x: float, y: float) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Get vertex with specified coordinates (x,y)

            Arguments:
                x: float, x vertice value

                y: float, y vertice value

            Return:
                Vertex (Class)
        &#39;&#39;&#39;
        for v in self.vertices:
            if v.x == x:
                if v.y == y:
                    return v
        return None

    # set the type of vertex at coords (x,y)
    def set_vertex_type(self, v_type: Vertex_Type, v: Vertex = None, x: float = None, y: float = None) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Set the type of vertex as given coordinates (x,y)

            Arguments:
                v_type: Vertex_Type (Class)

                v: Vertex (class), default = None

                x: float, x vertice value, default = None

                y: float, y vertice value, default = None

            Return:
                Vertex (class)
        &#39;&#39;&#39;

        if v is None:
            if x is None or y is None:
                raise ValueError(&#39;must specify either vertex or (x,y)&#39;)
            else:
                v = Vertex(x, y)

        for i in range(len(self.vertices)):
            if self.vertices[i] == v:
                self.vertices[i].vertex_type = v_type
                return self.vertices[i]

        return None

    # set the type of vertex at coords (x,y)
    def set_vertex_coords(self, v: Vertex, x: float, y: float) -&gt; Vertex:
        &#39;&#39;&#39;
        ## Set the type of vertex as coordinates (x,y)

            Arguments:
                v: Vertex (class)

                x: float, x vertice value

                y: float, y vertice value

            Return:
                list, vertices of a given type
        &#39;&#39;&#39;

        for i in range(len(self.vertices)):
            if self.vertices[i] == v:
                self.vertices[i].x = x
                self.vertices[i].y = y
                return self.vertices[i]

        return None
    
    # set vertex on graph
    def add_vertex(self, v: Vertex):
        
        # check if vertex not in graph already
        for graph_v in self.vertices:
            if graph_v.x == v.x and graph_v.y == v.y:
                raise ValueError(&#34;Vertex already in the graph&#34;)
        
        # set other parameters for vertex
        v.time_to_acquire = self.site_structures.site_acquire_times[v.vertex_type]
        v.reward = self.site_structures.site_rewards[v.vertex_type]
        v.mult_time = self.site_structures.site_mult_time[v.vertex_type]
        v.mult_time_active = self.site_structures.site_mult_time_active[v.vertex_type]
        v.mult_worker = self.site_structures.site_mult_worker[v.vertex_type]
        v.expiration_time = self.site_structures.site_expiration_times[v.vertex_type]
        self.vertices.append(v)
        self.make_graph_connected()
        self.set_edges()
    
    # remove vertex from graph
    def remove_vertex(self, x: float, y: float):
        for i, v in enumerate(self.vertices):
            if v.x == x and v.y == y:
                self.vertices.pop(i)
        self.set_edges()
                
    def _set_site_structures(self):
        for v in self.vertices:
            vt = v.vertex_type
            if vt in v.accessible_types():
                if self.site_structures.site_acquire_times[vt] != utils.NotSpecI:
                    v.time_to_acquire = self.site_structures.site_acquire_times[vt]
                if self.site_structures.site_rewards[vt] != utils.NotSpecF:
                    v.reward = self.site_structures.site_rewards[vt]
                if self.site_structures.site_mult_time[vt] != utils.NotSpecF:
                    v.mult_time = self.site_structures.site_mult_time[vt]
                if self.site_structures.site_mult_time_active[vt] != utils.NotSpecI:
                    v.mult_time_active = self.site_structures.site_mult_time_active[vt]
                if self.site_structures.site_mult_worker[vt] != utils.NotSpecF:
                    v.mult_worker = self.site_structures.site_mult_worker[vt]
                if self.site_structures.site_expiration_times[vt] != utils.NotSpecI:
                    v.expiration_time = self.site_structures.site_expiration_times[vt]

    # closest vertices to specified vertex
    def closest_vertices(self, v: Vertex) -&gt; List:
        # get distances to other vertices
        dist = []
        for v2 in self.vertices:
            d = Edge(v, v2).length
            if d &gt; 0:
                dist.append(d)

        dist_min = min(dist)

        verts_closest = []
        for v2 in self.vertices:
            if Edge(v, v2).length == dist_min:
                verts_closest.append(v2)

        return verts_closest

    # get isolated vertices - those with no nearest neighbor
    # Return: list of deep copies of isolated vertices
    def isolated_vertices(self) -&gt; List:
        isol = []
        for v in self.vertices:
            vc = self.closest_vertices(v)
            if len(vc) &gt; 0:
                if Edge(v, vc[0]).nearest_neighbor():
                    continue
                else:
                    isol.append(v)
            else:
                isol.append(v)

        return isol

    # get adjacent vertices to specified vertex via edges
    def adjacent_vertices(self, v: Vertex) -&gt; List:
        edges_v = self.get_edges_at_vertex(v)

        verts_adj = []
        for e in edges_v:
            v1, v2 = e.v1, e.v2
            if v1 != v:
                verts_adj.append(v1)
            else:
                verts_adj.append(v2)

        return verts_adj

    #
    # set up edges for travel: in_graph() method
    # defined in Edge class
    # Note: this method needs to be called if vertices are changed
    #
    def set_edges(self) -&gt; List:

        self.edges = []  # delete old edge set if there was one
        for v in self.vertices:
            for v2 in self.vertices:
                e = Edge(v, v2)
                if e.in_graph():  # does this edge meet the conditions to be in graph?
                    if e not in self.edges:  # may have (v2,v1) in edges
                        self.edges.append(e)
        return self.edges

    # get list of edges in given list
    # if edge list is not given, get info for all edges in graph
    def edges_info(self, edge_list: List = None) -&gt; List:
        info = {}
        if edge_list is None:
            edge_list = self.edges
        for e in edge_list:
            x1, y1 = e.v1.x, e.v1.y
            x2, y2 = e.v2.x, e.v2.y
            coords = ((x1, y1), (x2, y2))
            ct = 1
            if coords in info.keys():
                ct = info[coords] + 1
            info[((x1, y1), (x2, y2))] = ct

        return info

    # return edges containing specified vertex
    def get_edges_at_vertex(self, v: Vertex) -&gt; List:
        edges = []
        for e in self.edges:
            v1, v2 = e.v1, e.v2
            if v == v1 or v == v2:
                edges.append(e)

        return edges

    # randomly set origin and sites
    def set_random_sites_origin(self, n_site1: int, n_site2: int, n_site3: int) -&gt; None:

        num_sites = n_site1 + n_site2 + n_site3
        num_v = len(self.vertices)

        if num_v &lt; num_sites + 1:
            raise ValueError(f&#39;Not enough vertices on graph: require number vertices ({num_v}) &#39; +
                             f&#39;&gt;= num site 1 ({n_site1}) + num site 2 ({n_site2}) &#39; +
                             f&#39;+ num site 3 ({n_site3})+ 1&#39;
                             )

        index_verts = sample(range(0, num_v), num_sites + 1)  # sites and origin

        # set sites
        for i in index_verts[:n_site1]:
            self.vertices[i].vertex_type = Vertex_Type.SITE1
        for i in index_verts[n_site1: n_site1 + n_site2]:
            self.vertices[i].vertex_type = Vertex_Type.SITE2
        for i in index_verts[-n_site3 - 1: -1]:
            self.vertices[i].vertex_type = Vertex_Type.SITE3

        # set last to origin
        self.vertices[index_verts[-1]].vertex_type = Vertex_Type.ORIGIN
        self._set_site_structures()

    # return edge of minimum distance between two sets of vertices
    # this is the minimum distance of points (v1,v2) v1 in set1, v2 in set2
    @staticmethod
    def distance(vert_list_1: List, vert_list_2: List) -&gt; Edge:

        edges = []
        for v1 in vert_list_1:
            for v2 in vert_list_2:
                edges.append(Edge(v1, v2))

        edge_lens = [e.length for e in edges]

        min_len = min(edge_lens)

        return edges[edge_lens.index(min_len)]

    # depth first search
    def depth_first_search(self, v: Vertex, visited: List) -&gt; List:

        # mark current vertex as visited
        visited.append(v)

        # repeat for all vertices adjacent to v
        for v2 in self.adjacent_vertices(v):

            if v2 not in visited:
                # update the visited list
                visited = self.depth_first_search(v2, visited)

        return visited

    # connected components
    def connected_components(self) -&gt; List:

        visited = []
        cc = []

        for v in self.vertices:

            if v not in visited:
                comp_v = self.depth_first_search(v, [])
                visited += comp_v
                cc.append(comp_v)

        return cc

    # make graph connected by moving connected components in x then y directions
    # towards the largest component until the number of components is reduced
    def make_graph_connected(self) -&gt; None:

        if len(self.vertices) == 1:
            return

        # get largest component as anchor
        cc = self.connected_components()
        cc_len = [len(c) for c in cc]
        ind_max = cc_len.index(max(cc_len))
        anchor_component = cc[ind_max]
        components = cc[:ind_max] + cc[ind_max + 1:]

        while len(components) &gt; 0:

            c0 = components[0]

            # get vertices of min distance
            e_min = self.distance(anchor_component, c0)

            v1, v2 = e_min.v1, e_min.v2

            if v1 in anchor_component:
                va, v0 = v1, v2
            else:
                va, v0 = v2, v1

            # move c0 towards anchor
            sx = np.sign(va.x - v0.x)
            sy = np.sign(va.y - v0.y)

            cl = len(components)

            c0_translate_x = deepcopy(c0)
            ind_v0 = c0_translate_x.index(v0)
            x_diff = sx
            y_diff = sy

            # keep translating until:
            #   - number of connected components decrease, or
            #   - the set we are translating is directly above or below anchor
            #     ie  sx changes to zero (at this point, we&#39;ll translate in y dir)
            while len(components) == cl and x_diff == sx and x_diff != 0:

                # translate x components of c0
                for i in range(len(c0)):
                    c = c0[i]
                    # note  cmin is translated to va + (sx,0)
                    # which is a translation by (vax + sx - v0x)
                    x_new = c.x + sx
                    y_new = c.y
                    self.set_vertex_coords(v=c, x=x_new, y=y_new)  # change graph vert
                    c0_translate_x[i].x, c0_translate_x[i].y = x_new, y_new

                self.set_edges()  # update edges since vertices were changed

                # recompute the number of connected components &amp; anchor
                cc = self.connected_components()
                cc_len = [len(c) for c in cc]
                ind_max = cc_len.index(max(cc_len))
                anchor_component = cc[ind_max]
                components = cc[:ind_max] + cc[ind_max + 1:]

                if len(components) == cl:
                    x0 = c0_translate_x[ind_v0].x
                    x_diff = np.sign(va.x - x0)

            # translate y components of c0_translate_x
            c0_translate_y = deepcopy(c0_translate_x)

            # keep translating until:
            #   - number of connected components decrease, or
            #   - the set we are translating is directly left or right of anchor
            #     ie  sy changes to zero
            while len(components) == cl and y_diff == sy and y_diff != 0:

                for i in range(len(c0_translate_y)):
                    c = c0_translate_y[i]
                    # note  cmin is translated to va + (0,sy)
                    # which is a translation by (vay + sy - v0y)
                    x_new = c.x
                    y_new = c.y + sy
                    self.set_vertex_coords(v=c, x=x_new, y=y_new)
                    c0_translate_y[i].x, c0_translate_y[i].y = x_new, y_new

                self.set_edges()  # update edges since vertices were changed

                # recompute the number of connected components &amp; anchor
                cc = self.connected_components()
                cc_len = [len(c) for c in cc]
                ind_max = cc_len.index(max(cc_len))
                anchor_component = cc[ind_max]
                components = cc[:ind_max] + cc[ind_max + 1:]

                if len(components) == cl:
                    y0 = c0_translate_y[ind_v0].y
                    y_diff = np.sign(va.y - y0)

            if len(components) == cl:
                # neither translation above resulted in the nearest neighboring of sets
                print(&#39;after translations in x and y, no reduction in components&#39;)
                print(&#39;components:&#39;)
                for c in components:
                    print(f&#39;{self.vertices_info(c)}&#39;)
                return

        #
        # make minimum x and y coords of graph zero
        #
        x_coords = [v.x for v in self.vertices]
        y_coords = [v.y for v in self.vertices]

        x_min = min(x_coords)
        y_min = min(y_coords)

        for v in self.vertices:
            v.x = v.x - x_min
            v.y = v.y - y_min

        self.set_edges()  # update edges since vertices were changed

        return

    # graph vertices
    # color vertices in verts_list OTHER color
    def print_graph(self, vert_list: List = None, filename_out=None) -&gt; None:
        color_dict = {
            &#39;BASIC&#39;: &#39;black&#39;,
            &#39;ORIGIN&#39;: &#39;yellow&#39;,
            &#39;SITE1&#39;: &#39;red&#39;,
            &#39;SITE2&#39;: &#39;blue&#39;,
            &#39;SITE3&#39;: &#39;green&#39;
        }

        types = color_dict.keys()

        # plot edges
        for e in self.edges:
            x_values = [e.v1.x, e.v2.x]
            y_values = [e.v1.y, e.v2.y]
            plt.plot(x_values, y_values, linestyle=&#34;--&#34;, color=&#39;black&#39;)

        plots = []
        for t in types:
            verts = self.get_vertices_type(Vertex_Type[t])
            x, y = vertices_array(verts).T
            p = plt.scatter(x, y, color=color_dict[t])
            plots.append(p)

        # color vertices in vert_list orange
        if vert_list is not None:
            x, y = vertices_array(vert_list).T
            plt.scatter(x, y, color=&#39;orange&#39;)

        plt.legend(tuple(plots), tuple(types), scatterpoints=1,
                   bbox_to_anchor=(0.5, -.2),
                   loc=&#39;lower center&#39;,
                   ncol=3,
                   fontsize=8)

        if filename_out is not None:
            plt.savefig(filename_out)

        plt.show()

    # save graph to file
    def save(self, file_name: str) -&gt; None:
        fn = file_name

        with open(fn, &#39;wb&#39;) as f:
            pickle.dump(self, f)

        # get all paths from vertex v1 to vertex v2
        # return: List of lists, each member list being vertices that represent the path
        # Note:
        #  - adjacent vertices in the list are adjacent in the graph - ie compose an edge
        #  - returned paths do not have cycles - each vertex in the path is visited only once
        #  - max_len argument, if set, will limit paths to this maximum length

    def paths(self, v1: Vertex, v2: Vertex, max_len: float = math.inf, visited: List = None, ) -&gt; List:

        if visited is None:
            visited = []

        visited.append(v1)

        adj_list = self.adjacent_vertices(v1)
        vnext_list = [v for v in adj_list if v not in visited]

        if len(vnext_list) == 0 or len(visited) &gt; max_len:  # nothing left
            return [[]]
        else:
            paths_return = []
            # try next possible paths
            for vnext in vnext_list:  # get adj verts not visited

                visited_next = deepcopy(visited)

                if vnext == v2:
                    paths_next = [[v2]]
                else:
                    paths_next = self.paths(vnext, v2, max_len, visited_next)  # get path vnext to end v2

                for p in paths_next:
                    if len(p) &gt; 0:
                        paths_return.append([v1] + p)  # path from start v1 to end v2

            return paths_return

        # save graph data to json

    def save_to_json(self, file_name: str) -&gt; None:
        graph_json = {}
        graph_json[&#39;vertices&#39;] = {}
        for v in self.vertices:  # set up dict
            graph_json[&#39;vertices&#39;][str(v.x)] = {}
        for v in self.vertices:  # set up dict
            graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)] = {}

        for v in self.vertices:
            for k in vars(v).keys():
                if k != &#39;x&#39; and k != &#39;y&#39;:
                    val = getattr(v, k)
                    # print(f&#39;v={(v.x,v.y)}  {k}={k}, type k={type(k)}, val={val}, typev={type(val)}&#39;)
                    graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)][k] = getattr(v, k)

        graph_json[&#39;edges&#39;] = []
        for e in self.edges:
            ej = [e.v1.x, e.v1.y, e.v2.x, e.v2.y]
            ejs = [str(val) for val in ej]
            graph_json[&#39;edges&#39;].append(ejs)

        # save to json
        with open(file_name, &#39;w&#39;) as f:
            json.dump(graph_json, f)

        # load graph data from json

    def load_from_json(self, file_name: str) -&gt; None:
        # dict to convert integer keys to Worker_Type keys
        wt_dict = {}
        lwt = list(Worker_Type.__members__.values())
        for i in range(len(lwt)):
            wt = lwt[i]
            wt_dict[wt.value] = wt

        # dict to convert integer keys to Vertex_Type keys
        vt_dict = {}
        lvt = list(Vertex_Type.__members__.values())
        for i in range(len(lvt)):
            vt = lvt[i]
            vt_dict[vt.value] = vt

        with open(file_name) as f:
            gj = json.load(f)

        vertsj = gj[&#39;vertices&#39;]
        edgesj = gj[&#39;edges&#39;]

        vertices = []
        for xs in vertsj.keys():
            x = float(xs)
            vertsj_x = vertsj[xs]
            for ys in vertsj_x.keys():
                y = float(ys)
                vj = vertsj_x[ys]
                v = Vertex(x, y)

                # set properties
                for k in vj.keys():
                    if k in (&#39;reward&#39;, &#39;mult_time&#39;):
                        setattr(v, k, float(vj[k]))

                    elif k in (&#39;expiration_time&#39;, &#39;time_to_acquire&#39;):
                        if vj[k] is None:
                            val = None
                        else:
                            val = int(vj[k])

                        setattr(v, k, val)

                    elif k == &#39;vertex_type&#39;:
                        setattr(v, k, vt_dict[int(vj[k])])

                    elif k == &#39;mult_worker&#39;:
                        # create Worker_Type keys
                        mult_worker = {}
                        for kwt in vj[k].keys():
                            mult_worker[wt_dict[int(kwt)]] = vj[k][kwt]
                        setattr(v, k, mult_worker)

                    elif k == &#39;mult_time_active&#39;:
                        setattr(v, k, (vj[k][0], vj[k][1]))

                vertices.append(v)

        edges = []
        for ej in edgesj:
            x1, y1 = float(ej[0]), float(ej[1])
            x2, y2 = float(ej[2]), float(ej[3])

            # get v1 and v2
            v1, v2 = None, None
            for v in vertices:
                if v.x == x1 and v.y == y1:
                    v1 = v
                if v.x == x2 and v.y == y2:
                    v2 = v

            if v1 is None:
                raise RuntimeError(f&#39;{(x1, y1)} in json file edges, but not in json file vertices&#39;)
            if v2 is None:
                raise RuntimeError(f&#39;{(x2, y2)} in json file edges, but not in json file vertices&#39;)

            e = Edge(v1, v2)
            edges.append(e)

        self.vertices = vertices  # no errors, set up verts &amp; edges
        self.edges = edges</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="lyra_graphtool.graph.Graph.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>vert_list_1:List, vert_list_2:List) ><a title="lyra_graphtool.edge.Edge" href="edge.html#lyra_graphtool.edge.Edge">Edge</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def distance(vert_list_1: List, vert_list_2: List) -&gt; Edge:

    edges = []
    for v1 in vert_list_1:
        for v2 in vert_list_2:
            edges.append(Edge(v1, v2))

    edge_lens = [e.length for e in edges]

    min_len = min(edge_lens)

    return edges[edge_lens.index(min_len)]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lyra_graphtool.graph.Graph.add_vertex"><code class="name flex">
<span>def <span class="ident">add_vertex</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vertex(self, v: Vertex):
    
    # check if vertex not in graph already
    for graph_v in self.vertices:
        if graph_v.x == v.x and graph_v.y == v.y:
            raise ValueError(&#34;Vertex already in the graph&#34;)
    
    # set other parameters for vertex
    v.time_to_acquire = self.site_structures.site_acquire_times[v.vertex_type]
    v.reward = self.site_structures.site_rewards[v.vertex_type]
    v.mult_time = self.site_structures.site_mult_time[v.vertex_type]
    v.mult_time_active = self.site_structures.site_mult_time_active[v.vertex_type]
    v.mult_worker = self.site_structures.site_mult_worker[v.vertex_type]
    v.expiration_time = self.site_structures.site_expiration_times[v.vertex_type]
    self.vertices.append(v)
    self.make_graph_connected()
    self.set_edges()</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.adjacent_vertices"><code class="name flex">
<span>def <span class="ident">adjacent_vertices</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjacent_vertices(self, v: Vertex) -&gt; List:
    edges_v = self.get_edges_at_vertex(v)

    verts_adj = []
    for e in edges_v:
        v1, v2 = e.v1, e.v2
        if v1 != v:
            verts_adj.append(v1)
        else:
            verts_adj.append(v2)

    return verts_adj</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.closest_vertices"><code class="name flex">
<span>def <span class="ident">closest_vertices</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closest_vertices(self, v: Vertex) -&gt; List:
    # get distances to other vertices
    dist = []
    for v2 in self.vertices:
        d = Edge(v, v2).length
        if d &gt; 0:
            dist.append(d)

    dist_min = min(dist)

    verts_closest = []
    for v2 in self.vertices:
        if Edge(v, v2).length == dist_min:
            verts_closest.append(v2)

    return verts_closest</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.connected_components"><code class="name flex">
<span>def <span class="ident">connected_components</span></span>(<span>self) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connected_components(self) -&gt; List:

    visited = []
    cc = []

    for v in self.vertices:

        if v not in visited:
            comp_v = self.depth_first_search(v, [])
            visited += comp_v
            cc.append(comp_v)

    return cc</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.depth_first_search"><code class="name flex">
<span>def <span class="ident">depth_first_search</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>, visited:List) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth_first_search(self, v: Vertex, visited: List) -&gt; List:

    # mark current vertex as visited
    visited.append(v)

    # repeat for all vertices adjacent to v
    for v2 in self.adjacent_vertices(v):

        if v2 not in visited:
            # update the visited list
            visited = self.depth_first_search(v2, visited)

    return visited</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.edges_info"><code class="name flex">
<span>def <span class="ident">edges_info</span></span>(<span>self, edge_list:List=None) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edges_info(self, edge_list: List = None) -&gt; List:
    info = {}
    if edge_list is None:
        edge_list = self.edges
    for e in edge_list:
        x1, y1 = e.v1.x, e.v1.y
        x2, y2 = e.v2.x, e.v2.y
        coords = ((x1, y1), (x2, y2))
        ct = 1
        if coords in info.keys():
            ct = info[coords] + 1
        info[((x1, y1), (x2, y2))] = ct

    return info</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.get_edges_at_vertex"><code class="name flex">
<span>def <span class="ident">get_edges_at_vertex</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges_at_vertex(self, v: Vertex) -&gt; List:
    edges = []
    for e in self.edges:
        v1, v2 = e.v1, e.v2
        if v == v1 or v == v2:
            edges.append(e)

    return edges</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.get_vertex_xy"><code class="name flex">
<span>def <span class="ident">get_vertex_xy</span></span>(<span>self, x:float, y:float) ><a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="get-vertex-with-specified-coordinates-xy">Get vertex with specified coordinates (x,y)</h2>
<pre><code>Arguments:
    x: float, x vertice value

    y: float, y vertice value

Return:
    Vertex (Class)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertex_xy(self, x: float, y: float) -&gt; Vertex:
    &#39;&#39;&#39;
    ## Get vertex with specified coordinates (x,y)

        Arguments:
            x: float, x vertice value

            y: float, y vertice value

        Return:
            Vertex (Class)
    &#39;&#39;&#39;
    for v in self.vertices:
        if v.x == x:
            if v.y == y:
                return v
    return None</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.get_vertices_type"><code class="name flex">
<span>def <span class="ident">get_vertices_type</span></span>(<span>self, v_type:<a title="lyra_graphtool.vertex.Vertex_Type" href="vertex.html#lyra_graphtool.vertex.Vertex_Type">Vertex_Type</a>) >List</span>
</code></dt>
<dd>
<div class="desc"><h2 id="get-vertices-of-a-specific-type">Get vertices of a specific type</h2>
<pre><code>Arguments:
    v_type: Vertex_Type (Class)

Return:
    list, vertices of a given type
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertices_type(self, v_type: Vertex_Type) -&gt; List:
    &#39;&#39;&#39;
    ## Get vertices of a specific type

        Arguments:
            v_type: Vertex_Type (Class)

        Return:
            list, vertices of a given type
    &#39;&#39;&#39;
    # make sure type is legitimate
    if v_type not in Vertex_Type:
        types = list(Vertex_Type.__members__)
        raise ValueError(f&#39;vertex type {v_type} is not in vertex_type.{types}&#39;)

    # get vertices of given type
    verts = []
    for v in self.vertices:
        if v.vertex_type == v_type:
            verts.append(v)

    return verts</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.isolated_vertices"><code class="name flex">
<span>def <span class="ident">isolated_vertices</span></span>(<span>self) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isolated_vertices(self) -&gt; List:
    isol = []
    for v in self.vertices:
        vc = self.closest_vertices(v)
        if len(vc) &gt; 0:
            if Edge(v, vc[0]).nearest_neighbor():
                continue
            else:
                isol.append(v)
        else:
            isol.append(v)

    return isol</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.load_from_json"><code class="name flex">
<span>def <span class="ident">load_from_json</span></span>(<span>self, file_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_json(self, file_name: str) -&gt; None:
    # dict to convert integer keys to Worker_Type keys
    wt_dict = {}
    lwt = list(Worker_Type.__members__.values())
    for i in range(len(lwt)):
        wt = lwt[i]
        wt_dict[wt.value] = wt

    # dict to convert integer keys to Vertex_Type keys
    vt_dict = {}
    lvt = list(Vertex_Type.__members__.values())
    for i in range(len(lvt)):
        vt = lvt[i]
        vt_dict[vt.value] = vt

    with open(file_name) as f:
        gj = json.load(f)

    vertsj = gj[&#39;vertices&#39;]
    edgesj = gj[&#39;edges&#39;]

    vertices = []
    for xs in vertsj.keys():
        x = float(xs)
        vertsj_x = vertsj[xs]
        for ys in vertsj_x.keys():
            y = float(ys)
            vj = vertsj_x[ys]
            v = Vertex(x, y)

            # set properties
            for k in vj.keys():
                if k in (&#39;reward&#39;, &#39;mult_time&#39;):
                    setattr(v, k, float(vj[k]))

                elif k in (&#39;expiration_time&#39;, &#39;time_to_acquire&#39;):
                    if vj[k] is None:
                        val = None
                    else:
                        val = int(vj[k])

                    setattr(v, k, val)

                elif k == &#39;vertex_type&#39;:
                    setattr(v, k, vt_dict[int(vj[k])])

                elif k == &#39;mult_worker&#39;:
                    # create Worker_Type keys
                    mult_worker = {}
                    for kwt in vj[k].keys():
                        mult_worker[wt_dict[int(kwt)]] = vj[k][kwt]
                    setattr(v, k, mult_worker)

                elif k == &#39;mult_time_active&#39;:
                    setattr(v, k, (vj[k][0], vj[k][1]))

            vertices.append(v)

    edges = []
    for ej in edgesj:
        x1, y1 = float(ej[0]), float(ej[1])
        x2, y2 = float(ej[2]), float(ej[3])

        # get v1 and v2
        v1, v2 = None, None
        for v in vertices:
            if v.x == x1 and v.y == y1:
                v1 = v
            if v.x == x2 and v.y == y2:
                v2 = v

        if v1 is None:
            raise RuntimeError(f&#39;{(x1, y1)} in json file edges, but not in json file vertices&#39;)
        if v2 is None:
            raise RuntimeError(f&#39;{(x2, y2)} in json file edges, but not in json file vertices&#39;)

        e = Edge(v1, v2)
        edges.append(e)

    self.vertices = vertices  # no errors, set up verts &amp; edges
    self.edges = edges</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.make_graph_connected"><code class="name flex">
<span>def <span class="ident">make_graph_connected</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_graph_connected(self) -&gt; None:

    if len(self.vertices) == 1:
        return

    # get largest component as anchor
    cc = self.connected_components()
    cc_len = [len(c) for c in cc]
    ind_max = cc_len.index(max(cc_len))
    anchor_component = cc[ind_max]
    components = cc[:ind_max] + cc[ind_max + 1:]

    while len(components) &gt; 0:

        c0 = components[0]

        # get vertices of min distance
        e_min = self.distance(anchor_component, c0)

        v1, v2 = e_min.v1, e_min.v2

        if v1 in anchor_component:
            va, v0 = v1, v2
        else:
            va, v0 = v2, v1

        # move c0 towards anchor
        sx = np.sign(va.x - v0.x)
        sy = np.sign(va.y - v0.y)

        cl = len(components)

        c0_translate_x = deepcopy(c0)
        ind_v0 = c0_translate_x.index(v0)
        x_diff = sx
        y_diff = sy

        # keep translating until:
        #   - number of connected components decrease, or
        #   - the set we are translating is directly above or below anchor
        #     ie  sx changes to zero (at this point, we&#39;ll translate in y dir)
        while len(components) == cl and x_diff == sx and x_diff != 0:

            # translate x components of c0
            for i in range(len(c0)):
                c = c0[i]
                # note  cmin is translated to va + (sx,0)
                # which is a translation by (vax + sx - v0x)
                x_new = c.x + sx
                y_new = c.y
                self.set_vertex_coords(v=c, x=x_new, y=y_new)  # change graph vert
                c0_translate_x[i].x, c0_translate_x[i].y = x_new, y_new

            self.set_edges()  # update edges since vertices were changed

            # recompute the number of connected components &amp; anchor
            cc = self.connected_components()
            cc_len = [len(c) for c in cc]
            ind_max = cc_len.index(max(cc_len))
            anchor_component = cc[ind_max]
            components = cc[:ind_max] + cc[ind_max + 1:]

            if len(components) == cl:
                x0 = c0_translate_x[ind_v0].x
                x_diff = np.sign(va.x - x0)

        # translate y components of c0_translate_x
        c0_translate_y = deepcopy(c0_translate_x)

        # keep translating until:
        #   - number of connected components decrease, or
        #   - the set we are translating is directly left or right of anchor
        #     ie  sy changes to zero
        while len(components) == cl and y_diff == sy and y_diff != 0:

            for i in range(len(c0_translate_y)):
                c = c0_translate_y[i]
                # note  cmin is translated to va + (0,sy)
                # which is a translation by (vay + sy - v0y)
                x_new = c.x
                y_new = c.y + sy
                self.set_vertex_coords(v=c, x=x_new, y=y_new)
                c0_translate_y[i].x, c0_translate_y[i].y = x_new, y_new

            self.set_edges()  # update edges since vertices were changed

            # recompute the number of connected components &amp; anchor
            cc = self.connected_components()
            cc_len = [len(c) for c in cc]
            ind_max = cc_len.index(max(cc_len))
            anchor_component = cc[ind_max]
            components = cc[:ind_max] + cc[ind_max + 1:]

            if len(components) == cl:
                y0 = c0_translate_y[ind_v0].y
                y_diff = np.sign(va.y - y0)

        if len(components) == cl:
            # neither translation above resulted in the nearest neighboring of sets
            print(&#39;after translations in x and y, no reduction in components&#39;)
            print(&#39;components:&#39;)
            for c in components:
                print(f&#39;{self.vertices_info(c)}&#39;)
            return

    #
    # make minimum x and y coords of graph zero
    #
    x_coords = [v.x for v in self.vertices]
    y_coords = [v.y for v in self.vertices]

    x_min = min(x_coords)
    y_min = min(y_coords)

    for v in self.vertices:
        v.x = v.x - x_min
        v.y = v.y - y_min

    self.set_edges()  # update edges since vertices were changed

    return</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.paths"><code class="name flex">
<span>def <span class="ident">paths</span></span>(<span>self, v1:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>, v2:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>, max_len:float=inf, visited:List=None) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paths(self, v1: Vertex, v2: Vertex, max_len: float = math.inf, visited: List = None, ) -&gt; List:

    if visited is None:
        visited = []

    visited.append(v1)

    adj_list = self.adjacent_vertices(v1)
    vnext_list = [v for v in adj_list if v not in visited]

    if len(vnext_list) == 0 or len(visited) &gt; max_len:  # nothing left
        return [[]]
    else:
        paths_return = []
        # try next possible paths
        for vnext in vnext_list:  # get adj verts not visited

            visited_next = deepcopy(visited)

            if vnext == v2:
                paths_next = [[v2]]
            else:
                paths_next = self.paths(vnext, v2, max_len, visited_next)  # get path vnext to end v2

            for p in paths_next:
                if len(p) &gt; 0:
                    paths_return.append([v1] + p)  # path from start v1 to end v2

        return paths_return

    # save graph data to json</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.print_graph"><code class="name flex">
<span>def <span class="ident">print_graph</span></span>(<span>self, vert_list:List=None, filename_out=None) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_graph(self, vert_list: List = None, filename_out=None) -&gt; None:
    color_dict = {
        &#39;BASIC&#39;: &#39;black&#39;,
        &#39;ORIGIN&#39;: &#39;yellow&#39;,
        &#39;SITE1&#39;: &#39;red&#39;,
        &#39;SITE2&#39;: &#39;blue&#39;,
        &#39;SITE3&#39;: &#39;green&#39;
    }

    types = color_dict.keys()

    # plot edges
    for e in self.edges:
        x_values = [e.v1.x, e.v2.x]
        y_values = [e.v1.y, e.v2.y]
        plt.plot(x_values, y_values, linestyle=&#34;--&#34;, color=&#39;black&#39;)

    plots = []
    for t in types:
        verts = self.get_vertices_type(Vertex_Type[t])
        x, y = vertices_array(verts).T
        p = plt.scatter(x, y, color=color_dict[t])
        plots.append(p)

    # color vertices in vert_list orange
    if vert_list is not None:
        x, y = vertices_array(vert_list).T
        plt.scatter(x, y, color=&#39;orange&#39;)

    plt.legend(tuple(plots), tuple(types), scatterpoints=1,
               bbox_to_anchor=(0.5, -.2),
               loc=&#39;lower center&#39;,
               ncol=3,
               fontsize=8)

    if filename_out is not None:
        plt.savefig(filename_out)

    plt.show()</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.remove_vertex"><code class="name flex">
<span>def <span class="ident">remove_vertex</span></span>(<span>self, x:float, y:float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_vertex(self, x: float, y: float):
    for i, v in enumerate(self.vertices):
        if v.x == x and v.y == y:
            self.vertices.pop(i)
    self.set_edges()</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name: str) -&gt; None:
    fn = file_name

    with open(fn, &#39;wb&#39;) as f:
        pickle.dump(self, f)

    # get all paths from vertex v1 to vertex v2
    # return: List of lists, each member list being vertices that represent the path
    # Note:
    #  - adjacent vertices in the list are adjacent in the graph - ie compose an edge
    #  - returned paths do not have cycles - each vertex in the path is visited only once
    #  - max_len argument, if set, will limit paths to this maximum length</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.save_to_json"><code class="name flex">
<span>def <span class="ident">save_to_json</span></span>(<span>self, file_name:str) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_json(self, file_name: str) -&gt; None:
    graph_json = {}
    graph_json[&#39;vertices&#39;] = {}
    for v in self.vertices:  # set up dict
        graph_json[&#39;vertices&#39;][str(v.x)] = {}
    for v in self.vertices:  # set up dict
        graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)] = {}

    for v in self.vertices:
        for k in vars(v).keys():
            if k != &#39;x&#39; and k != &#39;y&#39;:
                val = getattr(v, k)
                # print(f&#39;v={(v.x,v.y)}  {k}={k}, type k={type(k)}, val={val}, typev={type(val)}&#39;)
                graph_json[&#39;vertices&#39;][str(v.x)][str(v.y)][k] = getattr(v, k)

    graph_json[&#39;edges&#39;] = []
    for e in self.edges:
        ej = [e.v1.x, e.v1.y, e.v2.x, e.v2.y]
        ejs = [str(val) for val in ej]
        graph_json[&#39;edges&#39;].append(ejs)

    # save to json
    with open(file_name, &#39;w&#39;) as f:
        json.dump(graph_json, f)

    # load graph data from json</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.set_edges"><code class="name flex">
<span>def <span class="ident">set_edges</span></span>(<span>self) >List</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edges(self) -&gt; List:

    self.edges = []  # delete old edge set if there was one
    for v in self.vertices:
        for v2 in self.vertices:
            e = Edge(v, v2)
            if e.in_graph():  # does this edge meet the conditions to be in graph?
                if e not in self.edges:  # may have (v2,v1) in edges
                    self.edges.append(e)
    return self.edges</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.set_random_sites_origin"><code class="name flex">
<span>def <span class="ident">set_random_sites_origin</span></span>(<span>self, n_site1:int, n_site2:int, n_site3:int) >None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_random_sites_origin(self, n_site1: int, n_site2: int, n_site3: int) -&gt; None:

    num_sites = n_site1 + n_site2 + n_site3
    num_v = len(self.vertices)

    if num_v &lt; num_sites + 1:
        raise ValueError(f&#39;Not enough vertices on graph: require number vertices ({num_v}) &#39; +
                         f&#39;&gt;= num site 1 ({n_site1}) + num site 2 ({n_site2}) &#39; +
                         f&#39;+ num site 3 ({n_site3})+ 1&#39;
                         )

    index_verts = sample(range(0, num_v), num_sites + 1)  # sites and origin

    # set sites
    for i in index_verts[:n_site1]:
        self.vertices[i].vertex_type = Vertex_Type.SITE1
    for i in index_verts[n_site1: n_site1 + n_site2]:
        self.vertices[i].vertex_type = Vertex_Type.SITE2
    for i in index_verts[-n_site3 - 1: -1]:
        self.vertices[i].vertex_type = Vertex_Type.SITE3

    # set last to origin
    self.vertices[index_verts[-1]].vertex_type = Vertex_Type.ORIGIN
    self._set_site_structures()</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.set_vertex_coords"><code class="name flex">
<span>def <span class="ident">set_vertex_coords</span></span>(<span>self, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>, x:float, y:float) ><a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="set-the-type-of-vertex-as-coordinates-xy">Set the type of vertex as coordinates (x,y)</h2>
<pre><code>Arguments:
    v: Vertex (class)

    x: float, x vertice value

    y: float, y vertice value

Return:
    list, vertices of a given type
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vertex_coords(self, v: Vertex, x: float, y: float) -&gt; Vertex:
    &#39;&#39;&#39;
    ## Set the type of vertex as coordinates (x,y)

        Arguments:
            v: Vertex (class)

            x: float, x vertice value

            y: float, y vertice value

        Return:
            list, vertices of a given type
    &#39;&#39;&#39;

    for i in range(len(self.vertices)):
        if self.vertices[i] == v:
            self.vertices[i].x = x
            self.vertices[i].y = y
            return self.vertices[i]

    return None</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.set_vertex_type"><code class="name flex">
<span>def <span class="ident">set_vertex_type</span></span>(<span>self, v_type:<a title="lyra_graphtool.vertex.Vertex_Type" href="vertex.html#lyra_graphtool.vertex.Vertex_Type">Vertex_Type</a>, v:<a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>=None, x:float=None, y:float=None) ><a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a></span>
</code></dt>
<dd>
<div class="desc"><h2 id="set-the-type-of-vertex-as-given-coordinates-xy">Set the type of vertex as given coordinates (x,y)</h2>
<pre><code>Arguments:
    v_type: Vertex_Type (Class)

    v: Vertex (class), default = None

    x: float, x vertice value, default = None

    y: float, y vertice value, default = None

Return:
    Vertex (class)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vertex_type(self, v_type: Vertex_Type, v: Vertex = None, x: float = None, y: float = None) -&gt; Vertex:
    &#39;&#39;&#39;
    ## Set the type of vertex as given coordinates (x,y)

        Arguments:
            v_type: Vertex_Type (Class)

            v: Vertex (class), default = None

            x: float, x vertice value, default = None

            y: float, y vertice value, default = None

        Return:
            Vertex (class)
    &#39;&#39;&#39;

    if v is None:
        if x is None or y is None:
            raise ValueError(&#39;must specify either vertex or (x,y)&#39;)
        else:
            v = Vertex(x, y)

    for i in range(len(self.vertices)):
        if self.vertices[i] == v:
            self.vertices[i].vertex_type = v_type
            return self.vertices[i]

    return None</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.vertices_array"><code class="name flex">
<span>def <span class="ident">vertices_array</span></span>(<span>self) >numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><h2 id="method-to-get-numpy-array-of-vertices-v-v-x0y0-x1y1">Method to get numpy array of vertices v: v = [ [x0,y0], [x1,y1], &hellip; ]</h2>
<pre><code>Arguments:
    None

Return:
    np.ndarray, vertices
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_array(self) -&gt; np.ndarray:
    &#39;&#39;&#39;
    ## Method to get numpy array of vertices v: v = [ [x0,y0], [x1,y1], ... ]

        Arguments:
            None

        Return:
            np.ndarray, vertices
    &#39;&#39;&#39;
    return vertices_array(self.vertices)</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.graph.Graph.vertices_info"><code class="name flex">
<span>def <span class="ident">vertices_info</span></span>(<span>self, vert_list:List=None) >Dict</span>
</code></dt>
<dd>
<div class="desc"><h2 id="get-info-about-vertices-coordinates-and-type-if-no-arg-passed-get-info-about-all-vertices-in-graph">Get info about vertices: coordinates and type. If no arg passed, get info about all vertices in graph.</h2>
<pre><code>Arguments:
    vert_list: list, default = None
        list of vertices to recieve info about

Return:
    dict, vertice information
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertices_info(self, vert_list: List = None) -&gt; Dict:
    &#39;&#39;&#39;
    ## Get info about vertices: coordinates and type. If no arg passed, get info about all vertices in graph.

        Arguments:
            vert_list: list, default = None
                list of vertices to recieve info about

        Return:
            dict, vertice information
    &#39;&#39;&#39;
    info = {}
    if vert_list is None:
        vert_list = self.vertices
    none_ct = 0
    for v in vert_list:
        if v is not None:
            ct = 1
            if (v.x, v.y) in info.keys():
                ct = info[(v.x, v.y)][1] + 1
            info[(v.x, v.y)] = (v.vertex_type, ct)
        else:  # None
            none_ct += 1

        if none_ct &gt; 0:
            info[&#39;None&#39;] = none_ct

    return info</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lyra_graphtool.graph.Graph_Type"><code class="flex name class">
<span>class <span class="ident">Graph_Type</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph_Type(IntEnum):
    RANDOM = 0
    GRID = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lyra_graphtool.graph.Graph_Type.GRID"><code class="name">var <span class="ident">GRID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lyra_graphtool.graph.Graph_Type.RANDOM"><code class="name">var <span class="ident">RANDOM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lyra_graphtool" href="index.html">lyra_graphtool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lyra_graphtool.graph.Graph" href="#lyra_graphtool.graph.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="lyra_graphtool.graph.Graph.add_vertex" href="#lyra_graphtool.graph.Graph.add_vertex">add_vertex</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.adjacent_vertices" href="#lyra_graphtool.graph.Graph.adjacent_vertices">adjacent_vertices</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.closest_vertices" href="#lyra_graphtool.graph.Graph.closest_vertices">closest_vertices</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.connected_components" href="#lyra_graphtool.graph.Graph.connected_components">connected_components</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.depth_first_search" href="#lyra_graphtool.graph.Graph.depth_first_search">depth_first_search</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.distance" href="#lyra_graphtool.graph.Graph.distance">distance</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.edges_info" href="#lyra_graphtool.graph.Graph.edges_info">edges_info</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.get_edges_at_vertex" href="#lyra_graphtool.graph.Graph.get_edges_at_vertex">get_edges_at_vertex</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.get_vertex_xy" href="#lyra_graphtool.graph.Graph.get_vertex_xy">get_vertex_xy</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.get_vertices_type" href="#lyra_graphtool.graph.Graph.get_vertices_type">get_vertices_type</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.isolated_vertices" href="#lyra_graphtool.graph.Graph.isolated_vertices">isolated_vertices</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.load_from_json" href="#lyra_graphtool.graph.Graph.load_from_json">load_from_json</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.make_graph_connected" href="#lyra_graphtool.graph.Graph.make_graph_connected">make_graph_connected</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.paths" href="#lyra_graphtool.graph.Graph.paths">paths</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.print_graph" href="#lyra_graphtool.graph.Graph.print_graph">print_graph</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.remove_vertex" href="#lyra_graphtool.graph.Graph.remove_vertex">remove_vertex</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.save" href="#lyra_graphtool.graph.Graph.save">save</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.save_to_json" href="#lyra_graphtool.graph.Graph.save_to_json">save_to_json</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.set_edges" href="#lyra_graphtool.graph.Graph.set_edges">set_edges</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.set_random_sites_origin" href="#lyra_graphtool.graph.Graph.set_random_sites_origin">set_random_sites_origin</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.set_vertex_coords" href="#lyra_graphtool.graph.Graph.set_vertex_coords">set_vertex_coords</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.set_vertex_type" href="#lyra_graphtool.graph.Graph.set_vertex_type">set_vertex_type</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.vertices_array" href="#lyra_graphtool.graph.Graph.vertices_array">vertices_array</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph.vertices_info" href="#lyra_graphtool.graph.Graph.vertices_info">vertices_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lyra_graphtool.graph.Graph_Type" href="#lyra_graphtool.graph.Graph_Type">Graph_Type</a></code></h4>
<ul class="">
<li><code><a title="lyra_graphtool.graph.Graph_Type.GRID" href="#lyra_graphtool.graph.Graph_Type.GRID">GRID</a></code></li>
<li><code><a title="lyra_graphtool.graph.Graph_Type.RANDOM" href="#lyra_graphtool.graph.Graph_Type.RANDOM">RANDOM</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>