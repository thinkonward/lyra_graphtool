<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lyra_graphtool.configuration API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lyra_graphtool.configuration</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import pickle
from copy import deepcopy
from typing import Dict, Generic, List, Tuple, TypeVar

import numpy as np

from lyra_graphtool.edge import Edge
from lyra_graphtool.parameters import Parameters
from lyra_graphtool.worker import Worker, Worker_Type
from lyra_graphtool.vertex import Vertex, Vertex_Type


Config_Single_Time = TypeVar(&#39;Config_Single_Time&#39;)
Configuration = TypeVar(&#39;Configuration&#39;)


# single-time-step configuration
# Note: objects will have a deepcopy of the vertex. To modify a vertex
#       in the graph, use graph methods to get the graph&#39;s vertex.
class Config_Single_Time(Generic[Config_Single_Time]):

    def __init__(self, v: Vertex = None, access: bool = False):
        &#39;&#39;&#39;
        # Class controls single-time-step configuration
        
            Note: objects will have a deepcopy of the vertex. To modify a vertex
                in the graph, use graph methods to get the graph&#39;s vertex.
        &#39;&#39;&#39;

        self.v = deepcopy(v)  # occupy this vertex at corresponding time
        self.access = access  # True: access this vertex&#39;s resources; False: don&#39;t access

    # display info about object
    def info(self, verbose=False) -&gt; List:
        &#39;&#39;&#39;
        # Displays list of information about the object
        
            Arguments:
                verbose : bool, default = False

            Return: 
                list
        &#39;&#39;&#39;
        if self.v is not None:
            x, y = self.v.x, self.v.y
            vtype = self.v.vertex_type
        else:
            x, y = None, None
            vtype = None
        access = self.access
        if verbose:
            print(f&#39;[ ({x},{y}), {vtype}, acc={access} ]&#39;)
        return [(x, y), vtype, access]


# noinspection SpellCheckingInspection
class Configuration(Generic[Configuration]):

    def __init__(self, params: Parameters):
        &#39;&#39;&#39;
        # Generic class for configuring budget, worker type, duration, graphing, and worker costs

            Arguments:
                params:
                    budget - 
                    
                    duration_time - 

                    graph - 

                    worker_cost_rate - 

            Return:
                None

        &#39;&#39;&#39;
        self.parameters = params
        self.budget = params.budget
        self.duration_time = params.duration_time
        self.graph = params.graph
        self.worker_cost_rate = params.worker_cost_rate

        # compute max number of workers of each type depending on budget
        budget = params.budget

        worker_types = list(Worker_Type.__members__.values())
        self.worker_types = worker_types

        max_workers = {}  # indexed by Worker_Type
        for wt in worker_types:
            max_workers[wt] = int(np.floor(budget / self.worker_cost_rate[wt]))

        self.max_workers = max_workers

        # Set up schedules over time for each worker
        #
        # A schedule is a time-series of pairs
        #       (Vertex, access_status) = Config_Single_Time object
        # for each worker
        #        access_status = True: then take resources at site = Vertex
        #                      = False: do not take resources, only travel through
        #
        # The time series runs from day 0 to day params.duration_days

        # access config by
        #    config[worker_type][worker number] = {0:config_single, 1:config_single,... }
        self.config = {}

        for worker_type in worker_types:

            self.config[worker_type] = {}
            for worker_number in range(max_workers[worker_type]):

                # set up path/schedule for single worker
                schedule = {}
                for t in range(self.duration_time):
                    config_t = Config_Single_Time()
                    schedule[t] = config_t

                self.config[worker_type][worker_number] = schedule

    # get vertices from which a worker&#39;s path must start
    #
    # Note: this allows for generalizations - should avoid hard-coding
    #       constraints outside this class (ie by solvers)
    def get_vertices_start(self) -&gt; List:
        &#39;&#39;&#39;
        # Get list the vertices from which a worker&#39;s path must start
            
                Note: this allows for generalizations - should avoid hard-coding
                    constraints outside this class (ie by solvers)
            
            Arguments:
                None
            
            Return:
                list
        &#39;&#39;&#39;

        verts_graph = self.graph.get_vertices_type(Vertex_Type.ORIGIN)

        verts_start = []
        for v in verts_graph:
            verts_start.append(deepcopy(v))

        return verts_start

    # add schedule (deepcopy) to configuration
    # at wt, wn
    def add_sched(self, wt: Worker_Type, wn: int, sched: Dict) -&gt; None:
        &#39;&#39;&#39;    
        # Add a schedule (deepcopy) to configuration at wt, wn
        
            Arguments:

                wt: Worker_Type (class), int

                wn: int, number of workers
                
                sched: dict, schedule
            
            Return:

                None
        &#39;&#39;&#39;

        if len(sched) == self.duration_time:
            self.config[wt][wn] = deepcopy(sched)
        else:
            raise ValueError(f&#39;Schedule must have length {self.duration_time}.&#39;)

    # display info on given schedule
    @staticmethod
    def sched_info(sched: Dict) -&gt; List:
        &#39;&#39;&#39;
        # Display the info of the given schedule

            Arguments:

                sched: dict, schedule

            Return:
            
                list
        &#39;&#39;&#39;
        info = []
        for t in range(len(sched)):
            i = sched[t].info()  # [ (x,y), vtype, access ]
            info.append(f&#39;[t={t}, ({i[0][0]},{i[0][1]}), vtype={i[1]}, acc={i[2]} ]&#39;)
        return info

    # Method to return Worker object, that has rates compliant with configuration
    def get_worker(self, wt: Worker_Type) -&gt; Worker:
        &#39;&#39;&#39;
        # Method to return Worker object, that has rates compliant with configuration

            Arguments:
                wt: int, Worker_Type(class)\n

            Return:
                Worker(class)
        &#39;&#39;&#39;
        return Worker(wt, rates=self.worker_cost_rate)

    # Method returning dict of workers used in configuration
    def get_current_workers(self, config: Dict) -&gt; Dict:
        &#39;&#39;&#39;
        # Method returning dict of workers used in configuration

            Arguments:
                config: dict

            Returns: 
                dict
        &#39;&#39;&#39;
        used_workers = {}
        for wt in self.worker_types:
            used_workers[wt] = 0
            for wn, sched in config[wt].items():
                not_na = [1 if cs.v is not None else 0 for _, cs in sched.items()]
                if np.sum(not_na) &gt; 0:
                    used_workers[wt] += 1
        return used_workers

    # Method to return sites accessed in schedule
    # Return: dict with key (x,y) , value access_count: int
    # Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule
    def get_accessed_sites(self, schedule: Dict) -&gt; Tuple[Dict, str]:
        &#39;&#39;&#39;
        # Method to return sites accessed in a schedule
        
                Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule

            Parameters:
                schedule: dict
            
            Return: 
                dict with key (x,y) 

                value access_count: int
        &#39;&#39;&#39;
        accesses = {(vertex.x, vertex.y): 0 for vertex in self.graph.vertices
                    if vertex.vertex_type in self.graph.vertices[0].accessible_types()
                    }
        worker_message = &#34;Log of accesses:\n&#34;

        for wt in self.worker_types:
            for wn, sched in schedule[wt].items():
                t = 0
                while t &lt; len(sched):
                    curr_sched = sched[t]
                    if curr_sched.access is True:
                        t = t + max(curr_sched.v.time_to_acquire - 1, 0)
                        accesses[(curr_sched.v.x, curr_sched.v.y)] += 1
                        worker_message += f&#34;{wt.__str__()} number {wn} accessed &#34; \
                                          f&#34;{curr_sched.v.vertex_type.__str__()} at &#34; \
                                          f&#34;({curr_sched.v.x}, {curr_sched.v.y}) at time step {t}\n&#34;
                    t += 1
        return accesses, worker_message

    # Method to return maximum revenue for graph
    def get_max_revenue(self):
        &#39;&#39;&#39;
        # Method to return maximum revenue for graph

            Arguments:
                None

            Return:
                int, maximum revenue
                    max_revenue = amount_of_sites * single_reward
        &#39;&#39;&#39;
        max_revenue = 0
        for site_type in self.graph.vertices[0].accessible_types():
            amount_of_sites = len(self.graph.get_vertices_type(site_type))
            if amount_of_sites &lt; 1:
                continue
            single_reward = self.graph.get_vertices_type(site_type)[0].reward
            max_revenue += amount_of_sites * single_reward
        return max_revenue

    # True if site v is being accessed at time t in configuration
    # False otherwise
    def site_accessed_at_time(self, v: Vertex, t: int) -&gt; bool:
        &#39;&#39;&#39;
        # Returns bool value to determine if site is being accessed at time t in configuration

            Arguments:
                v: Vertex object, from lyra_graphtool.vertex
                
                t: int, time step value 

            Returns: 
                bool 
                    True if site v is being accessed at time t in configuration, False otherwise
        &#39;&#39;&#39;

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                max_time = len(self.config[wt][wn]) - 1

                if t &gt; max_time:
                    continue
                else:
                    cs = self.config[wt][wn][t]
                    if cs.v is not None:
                        if cs.v == v and cs.access:
                            return True

        return False

    # True if site v is being accessed in configuration
    # False otherwise
    def site_accessed(self, v: Vertex) -&gt; bool:
        &#39;&#39;&#39;
        # Returns bool value to determine if site is being accessed in configuration

            Arguments:
                v: Vertex object, from lyra_graphtool.vertex

            Returns: 
                bool 
                    True if site v is being accessed in configuration, False otherwise
        &#39;&#39;&#39;
        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                for t in range(len(self.config[wt][wn])):
                    cs = self.config[wt][wn][t]
                    if cs.v is not None:
                        if cs.v == v and cs.access:
                            return True
        return False

    # get length of a one worker schedule, how many timesteps was it active?
    @staticmethod
    def get_sched_path_length(sched: Dict) -&gt; int:
        &#39;&#39;&#39;
        # Method to return length of a one worker schedule. Used to determine how many timesteps was the worker active.

            Arguments:
                sched: dict, schedule 

            Returns: 
                int, number of active timesteps
        &#39;&#39;&#39;
        length = 0
        for t, cs in sched.items():
            if cs.v is not None:
                length += 1
        return length

    # True if schedule for single worker is empty
    # False if otherwise
    @staticmethod
    def is_empty(sched: Dict) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if single worker scedule is empty

            Arguments:
                sched: dict, schedule 

            Returns: 
                bool
                    True if schedule for single worker is empty, False if otherwise
        &#39;&#39;&#39;
        for t, cs in sched.items():
            if cs.v is not None:
                return False
        return True

    # Test if schedule is feasible spatially
    #   Note: a schedule is a sequence of Config_Single_Time objects
    #
    # 1. must start at ORIGIN type vertex if origin_flag==True
    # 2. ending vertex followed by None vertices
    # 3. if hire worker again at later time, must start at ORIGIN
    #
    # If origin_flag==False, schedule can start/restart at any vertex
    #
    # sched is Dict with values Config_Single_Time
    #
    def sched_feasible_space(self, sched: Dict, origin_flag=True) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule is spatially feasible

                Criteria
                    1. Must start at ORIGIN type vertex if origin_flag==True
                    2. Ending vertex followed by None vertices
                    3. If hire worker again at later time, must start at ORIGIN
                    Note: If origin_flag==False, schedule can start/restart at any vertex

            Arguments:
                sched: dict, schedule
                    Note: a schedule is a sequence of Config_Single_Time objects
                    
                origin_flag: bool, default True

            Returns: 
                bool
                    True if schedule is spatially feasible, false if otherwise
        &#39;&#39;&#39;
        if len(sched) != self.duration_time:
            raise ValueError(f&#39;Schedule must have {self.duration_time} keys to match duration_time.&#39;)

        if sched[0].v is not None and origin_flag:  # must start at origin if specified
            if sched[0].v.vertex_type != Vertex_Type.ORIGIN:
                return False

        # make sure adjacent vertices are in edge set
        v_prev = sched[0].v  # this may be None
        for t in range(1, self.duration_time):

            if sched[t].v is None:  # current vertex is None
                v_prev = None
                continue

            else:  # actual vertex:  path[t].v is not None

                if v_prev is None:  # vertex following None
                    if origin_flag:
                        if sched[t].v.vertex_type != Vertex_Type.ORIGIN:
                            return False
                        else:
                            v_prev = sched[t].v
                            continue  # ORIGIN following None is ok

                    else:  # any vertex can follow None
                        v_prev = sched[t].v
                        continue

                elif sched[t].v == v_prev:  # can stay at previous location
                    v_prev = sched[t].v
                    continue

                else:  # different location: vertex follows vertex (both not None)

                    # must be an edge in graph
                    e = Edge(v_prev, sched[t].v)
                    if e not in self.graph.edges:
                        return False
                    else:  # it is an edge
                        v_prev = sched[t].v
        return True

    #
    # Test all schedules for spatial feasibility
    #
    def sched_all_feasible_space(self, origin_flag=True) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if ALL schedules are spatially feasible

            Arguments:
                origin_flag: bool, default True

            Returns: 
                bool
                    True if schedule is spatially feasible, false if otherwise
        &#39;&#39;&#39;

        for worker_type in self.worker_types:

            for worker_number in range(len(self.config[worker_type])):

                sched = self.config[worker_type][worker_number]

                feas = self.sched_feasible_space(sched, origin_flag)

                if not feas:
                    return False
        return True

    # Test if a schedule&#39;s access/extract properties are feasible
    #
    # 1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
    # 2. Access constraint - must have Worker &gt;= SITE
    # 3. If accessing, must access site for v.days_to_acquire
    # 4. Cannot access after expiration time
    # 5. Cannot access a site more than once
    #
    def sched_feasible_access_sites(self, sched: Dict, worker_type: Worker_Type) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule&#39;s access/extract properties are feasible

                Criteria
                    1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
                    2. Access constraint - must have Worker &gt;= SITE
                    3. If accessing, must access site for v.days_to_acquire
                    4. Cannot access after expiration time
                    5. Cannot access a site more than once

            Arguments:
                sched: dict, schedule
                    Note: a schedule is a sequence of Config_Single_Time objects
                    
                worker_type: Worker_Type (class), from lyra_graphtool.worker

            Returns: 
                bool
                    True if schedule&#39;s access/extract properties are feasible, False if otherwise
        &#39;&#39;&#39;

        sites_accessed = []
        t = 0
        while t &lt; len(sched):

            v = sched[t].v
            acc = sched[t].access

            if v is None:
                if acc is not False:
                    return False
                else:
                    t += 1
                    continue

            if v.vertex_type == Vertex_Type.BASIC or v.vertex_type ==  Vertex_Type.ORIGIN:
                if acc is True:
                    return False
                else:
                    t += 1

            else:  # default - this vertex is a site
                if acc is True:

                    # test if sites was previously accessed
                    if v in sites_accessed:
                        return False
                    else:
                        sites_accessed.append(v)

                    # test if worker allowed to access
                    if self.get_worker(worker_type).access(v) is False:
                        return False

                    # test if accessing after expire
                    if v.expiration_time is not None:
                        if t &gt;= v.expiration_time:
                            return False

                    # set future times to same vertex with access=True
                    for t_off in range(1, v.time_to_acquire):
                        if t + t_off &lt; self.duration_time:
                            s2 = sched[t + t_off]
                            v2, acc2 = s2.v, s2.access
                        else:  # ran out of time: infeasible
                            return False

                        if v2 is None:
                            return False
                        elif v2 != v or acc2 is False:
                            return False

                    t += v.time_to_acquire
                else:
                    t += 1

        return True

    #
    # Test all schedules for access feasibility
    #
    # 1. Only one worker can access a specific site at a single point in time
    # 2. Once a site has been accessed, it can no longer be accessed at subsequent times
    #
    # noinspection SpellCheckingInspection
    def sched_all_feasible_access_sites(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule&#39;s access properties are feasible

                Criteria
                    1. Only one worker can access a specific site at a single point in time
                    2. Once a site has been accessed, it can no longer be accessed at subsequent times

            Arguments:
                None

            Return: 
                bool
                    True if schedule&#39;s access properties are feasible, False if otherwise
        &#39;&#39;&#39;

        # check schedule feasibility for each individual worker
        for worker_type in self.worker_types:

            for worker_number in range(len(self.config[worker_type])):

                sched = self.config[worker_type][worker_number]

                feas = self.sched_feasible_access_sites(sched, worker_type)

                if not feas:
                    return False

        # check that each site is accessed no more than one time
        accesses, _ = self.get_accessed_sites(self.config)

        if max(accesses.values()) &gt; 1:
            return False

        return True

    #
    # Calculate cost of a single-worker schedule
    #
    # sched is a dict with key=time, value=Config_Single_Time
    #   (for a single worker)
    #
    @staticmethod
    def cost_sched(sched: Dict, worker: Worker) -&gt; float:
        &#39;&#39;&#39;
        # Calculate the cost of a single-worker schedule

            Arguments:
                sched: dict,
                    sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                    worker: Worker (class), from lyra_graphtool.worker

            Returns:
                float, cost value of a single worker schedule
        &#39;&#39;&#39;

        cost_sched = 0
        for t in range(len(sched)):
            v = sched[t].v
            access = sched[t].access

            if v is None:  # worker not on payroll
                continue

            else:  # worker is on payroll

                cost_base = worker.worker_cost_rate
                cost = cost_base

                if access is True:

                    # get multipliers
                    mult_time = v.mult_time
                    mult_time_start = v.mult_time_active[0]
                    mult_time_end = v.mult_time_active[1]
                    mult_worker = v.mult_worker

                    # cost for time multiplier
                    if mult_time_start is not None and mult_time_end is not None:
                        if mult_time_start &lt;= t &lt;= mult_time_end:
                            cost += (mult_time - 1) * cost_base

                    # cost for site multiplier
                    wt = worker.worker_type
                    if wt in mult_worker.keys():
                        cost += (mult_worker[wt] - 1) * cost_base

                cost_sched += cost

        return cost_sched

    #
    # Calculate cost of entire configuration
    #
    # sched is a dict with key=time, value=Config_Single_Time
    #   (for a single worker)
    #
    # NOTE: default worker_cost_rate is used for each worker type
    def cost(self) -&gt; float:
        &#39;&#39;&#39;
        # Calculate the cost of the entire configuration
                Note: default worker_cost_rate is used for each worker type

            Arguments:
                None

            Returns:
                float, cost value of entire configuration
        &#39;&#39;&#39;

        cost_config = 0

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                sched = self.config[wt][wn]
                worker = self.get_worker(wt)
                cost_config += self.cost_sched(sched, worker)

        return cost_config

    # Budget Feasibility of Configuration
    def budget_feasible(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if budget is feasible for configuration. If Cost &lt;= Budget then Feasible else Not Feasible

            Arguments:
                None

            Returns:
                bool
                    True if budget is feasible, False if otherwise
        &#39;&#39;&#39;

        if self.cost() &lt;= self.budget:
            return True
        else:
            return False

    # test overall feasibility of config using above methods
    def feasible(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to test the overall feasibily using sched_all_feasibility_space()
        , sched_all_feasible_access_sites(), and budget_feasible()

            Arguments:
                None

            Returns:
                bool
                    True if all functions are feasible, False if otherwise
        &#39;&#39;&#39;

        feas_space = self.sched_all_feasible_space()
        feas_access = self.sched_all_feasible_access_sites()
        feas_budget = self.budget_feasible()

        feas = feas_space and feas_access and feas_budget

        return feas

    # calculate returns/revenue from schedule for single worker
    #
    # sched should be tested for feasibility by sched_feasible_access_sites
    # before calling this funciton
    #
    # Note: revenue depends on worker_type
    @staticmethod
    def sched_revenue(sched: Dict):
        &#39;&#39;&#39;
        # Method to calculate revenue from schedule for single worker
                Note: Sched should be tested for feasibility by sched_feasible_access_sites
                before calling this function

            Arguments:
                sched: dict, schedule
                    sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                    worker: Worker (class), from lyra_graphtool.worker

            Returns:
                int, revenue (depends on worker_type)
        &#39;&#39;&#39;

        revenue = 0
        t = 0
        while t &lt; len(sched):

            v = sched[t].v
            acc = sched[t].access

            if acc is False:  # this covers non-SITEx vertices and .v = None
                t += 1
                continue

            # at SITEx vertex AND accessing
            revenue += v.reward
            t += v.time_to_acquire

        return revenue

    # calculate returns/revenue for entire configuration
    #
    # sched should be tested for feasibility by sched_feasible_access_sites
    # before calling this funciton
    #
    def revenue(self):
        &#39;&#39;&#39;
        # Method to calculate revenue from schedule for entire configuration
                Note: Sched should be tested for feasibility by sched_feasible_access_sites
                before calling this function

            Arguments:
                None

            Returns:
                int, revenue value for entire configuration
        &#39;&#39;&#39;

        revenue = 0

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                sched = self.config[wt][wn]
                revenue += self.sched_revenue(sched)

        return revenue

    # save configuration to file
    def save(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Save configuration file to pickle format

            Arguments:
                filename: str, filepath for file to be saved

            Returns:
                None
        &#39;&#39;&#39;
        fn = file_name

        with open(fn, &#39;wb&#39;) as f:
            pickle.dump(self, f)

    # save Configuration.config schedule dictionary to json
    def save_to_json(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Save configuration schedule dictionary to json format

            Arguments:
                filename: str, filepath for file to be saved

            Returns:
                None
        &#39;&#39;&#39;
        config_json = {}
        for wt in self.worker_types:
            config_json[wt] = {}
            for wn in range(len(self.config[wt])):
                config_json[wt][wn] = {}
                sched = self.config[wt][wn]
                for t in range(len(sched)):
                    cs = sched[t]
                    v, access = cs.v, cs.access
                    if v is None:
                        cs_basic = [&#39;None&#39;, cs.access]
                    else:
                        cs_basic = [float(v.x), float(v.y), cs.access]
                    config_json[wt][wn][t] = cs_basic
        # save to json
        with open(file_name, &#39;w&#39;) as f:
            json.dump(config_json, f)

    # load json config into Configuration.config
    def load_from_json(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Load configuration schedule dictionary from json format into Configuration.config

            Arguments:
                filename: str, json filepath to import

            Returns:
                None
        &#39;&#39;&#39;

        def jsonKeys2int(x):
            if isinstance(x, dict):
                return {int(k): v for k, v in x.items()}
            return x

        with open(file_name) as f:
            d = json.load(f, object_hook=jsonKeys2int)

        config = {}
        for wt in self.worker_types:
            config[wt] = {}
            for wn in range(len(self.config[wt])):
                config[wt][wn] = {}
                sched = self.config[wt][wn]
                for t in range(len(sched)):
                    if wt in d.keys():
                        if wn in d[wt].keys():
                            if t in d[wt][wn].keys():
                                csj = d[wt][wn][t]
                                if csj[0] == &#39;None&#39;:
                                    config[wt][wn][t] = Config_Single_Time()
                                else:
                                    msg_err = f&#39;json dictionary in file {file_name} must have triple (float,float,bool) &#39; + \
                                              f&#39;at index {[wt, wn, t]}.&#39;
                                    if len(csj) != 3:
                                        raise ValueError(msg_err)
                                    x, y, access = csj[0], csj[1], csj[2]
                                    if not isinstance(x, float) or not isinstance(y, float) or not isinstance(access,
                                                                                                              bool):
                                        raise ValueError(msg_err)
                                    v = self.graph.get_vertex_xy(x, y)
                                    if v is None:
                                        raise ValueError(
                                            f&#39;Vertex in json file {file_name} with coords {(x, y)} not found in graph.&#39;)

                                    config[wt][wn][t] = Config_Single_Time(v, access)

        self.config = config  # no errors, copy config

    # override python deepcopy function, which is very slow
    # 1. use pickle.dumps() to write object to binary file
    # 2. use pickle.loads() to read binary file into new object
    # Argument
    #        memo: dummy variable to match format of deepcopy from copy library
    # Returns
    #        Node: deepcopy of original configuration
    #
    def __deepcopy__(self, memo):
        return pickle.loads(pickle.dumps(self, -1))  # -1 uses most recent protocol</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lyra_graphtool.configuration.Config_Single_Time"><code class="flex name class">
<span>class <span class="ident">Config_Single_Time</span></span>
<span>(</span><span>v: <a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a> = None, access: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p>
<h1 id="class-controls-single-time-step-configuration">Class controls single-time-step configuration</h1>
<pre><code>Note: objects will have a deepcopy of the vertex. To modify a vertex
    in the graph, use graph methods to get the graph's vertex.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config_Single_Time(Generic[Config_Single_Time]):

    def __init__(self, v: Vertex = None, access: bool = False):
        &#39;&#39;&#39;
        # Class controls single-time-step configuration
        
            Note: objects will have a deepcopy of the vertex. To modify a vertex
                in the graph, use graph methods to get the graph&#39;s vertex.
        &#39;&#39;&#39;

        self.v = deepcopy(v)  # occupy this vertex at corresponding time
        self.access = access  # True: access this vertex&#39;s resources; False: don&#39;t access

    # display info about object
    def info(self, verbose=False) -&gt; List:
        &#39;&#39;&#39;
        # Displays list of information about the object
        
            Arguments:
                verbose : bool, default = False

            Return: 
                list
        &#39;&#39;&#39;
        if self.v is not None:
            x, y = self.v.x, self.v.y
            vtype = self.v.vertex_type
        else:
            x, y = None, None
            vtype = None
        access = self.access
        if verbose:
            print(f&#39;[ ({x},{y}), {vtype}, acc={access} ]&#39;)
        return [(x, y), vtype, access]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lyra_graphtool.configuration.Config_Single_Time.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, verbose=False) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><h1 id="displays-list-of-information-about-the-object">Displays list of information about the object</h1>
<pre><code>Arguments:
    verbose : bool, default = False

Return: 
    list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, verbose=False) -&gt; List:
    &#39;&#39;&#39;
    # Displays list of information about the object
    
        Arguments:
            verbose : bool, default = False

        Return: 
            list
    &#39;&#39;&#39;
    if self.v is not None:
        x, y = self.v.x, self.v.y
        vtype = self.v.vertex_type
    else:
        x, y = None, None
        vtype = None
    access = self.access
    if verbose:
        print(f&#39;[ ({x},{y}), {vtype}, acc={access} ]&#39;)
    return [(x, y), vtype, access]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lyra_graphtool.configuration.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span></span>
<span>(</span><span>params: <a title="lyra_graphtool.parameters.Parameters" href="parameters.html#lyra_graphtool.parameters.Parameters">Parameters</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p>
<h1 id="generic-class-for-configuring-budget-worker-type-duration-graphing-and-worker-costs">Generic class for configuring budget, worker type, duration, graphing, and worker costs</h1>
<pre><code>Arguments:
    params:
        budget -

        duration_time -

        graph -

        worker_cost_rate -

Return:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configuration(Generic[Configuration]):

    def __init__(self, params: Parameters):
        &#39;&#39;&#39;
        # Generic class for configuring budget, worker type, duration, graphing, and worker costs

            Arguments:
                params:
                    budget - 
                    
                    duration_time - 

                    graph - 

                    worker_cost_rate - 

            Return:
                None

        &#39;&#39;&#39;
        self.parameters = params
        self.budget = params.budget
        self.duration_time = params.duration_time
        self.graph = params.graph
        self.worker_cost_rate = params.worker_cost_rate

        # compute max number of workers of each type depending on budget
        budget = params.budget

        worker_types = list(Worker_Type.__members__.values())
        self.worker_types = worker_types

        max_workers = {}  # indexed by Worker_Type
        for wt in worker_types:
            max_workers[wt] = int(np.floor(budget / self.worker_cost_rate[wt]))

        self.max_workers = max_workers

        # Set up schedules over time for each worker
        #
        # A schedule is a time-series of pairs
        #       (Vertex, access_status) = Config_Single_Time object
        # for each worker
        #        access_status = True: then take resources at site = Vertex
        #                      = False: do not take resources, only travel through
        #
        # The time series runs from day 0 to day params.duration_days

        # access config by
        #    config[worker_type][worker number] = {0:config_single, 1:config_single,... }
        self.config = {}

        for worker_type in worker_types:

            self.config[worker_type] = {}
            for worker_number in range(max_workers[worker_type]):

                # set up path/schedule for single worker
                schedule = {}
                for t in range(self.duration_time):
                    config_t = Config_Single_Time()
                    schedule[t] = config_t

                self.config[worker_type][worker_number] = schedule

    # get vertices from which a worker&#39;s path must start
    #
    # Note: this allows for generalizations - should avoid hard-coding
    #       constraints outside this class (ie by solvers)
    def get_vertices_start(self) -&gt; List:
        &#39;&#39;&#39;
        # Get list the vertices from which a worker&#39;s path must start
            
                Note: this allows for generalizations - should avoid hard-coding
                    constraints outside this class (ie by solvers)
            
            Arguments:
                None
            
            Return:
                list
        &#39;&#39;&#39;

        verts_graph = self.graph.get_vertices_type(Vertex_Type.ORIGIN)

        verts_start = []
        for v in verts_graph:
            verts_start.append(deepcopy(v))

        return verts_start

    # add schedule (deepcopy) to configuration
    # at wt, wn
    def add_sched(self, wt: Worker_Type, wn: int, sched: Dict) -&gt; None:
        &#39;&#39;&#39;    
        # Add a schedule (deepcopy) to configuration at wt, wn
        
            Arguments:

                wt: Worker_Type (class), int

                wn: int, number of workers
                
                sched: dict, schedule
            
            Return:

                None
        &#39;&#39;&#39;

        if len(sched) == self.duration_time:
            self.config[wt][wn] = deepcopy(sched)
        else:
            raise ValueError(f&#39;Schedule must have length {self.duration_time}.&#39;)

    # display info on given schedule
    @staticmethod
    def sched_info(sched: Dict) -&gt; List:
        &#39;&#39;&#39;
        # Display the info of the given schedule

            Arguments:

                sched: dict, schedule

            Return:
            
                list
        &#39;&#39;&#39;
        info = []
        for t in range(len(sched)):
            i = sched[t].info()  # [ (x,y), vtype, access ]
            info.append(f&#39;[t={t}, ({i[0][0]},{i[0][1]}), vtype={i[1]}, acc={i[2]} ]&#39;)
        return info

    # Method to return Worker object, that has rates compliant with configuration
    def get_worker(self, wt: Worker_Type) -&gt; Worker:
        &#39;&#39;&#39;
        # Method to return Worker object, that has rates compliant with configuration

            Arguments:
                wt: int, Worker_Type(class)\n

            Return:
                Worker(class)
        &#39;&#39;&#39;
        return Worker(wt, rates=self.worker_cost_rate)

    # Method returning dict of workers used in configuration
    def get_current_workers(self, config: Dict) -&gt; Dict:
        &#39;&#39;&#39;
        # Method returning dict of workers used in configuration

            Arguments:
                config: dict

            Returns: 
                dict
        &#39;&#39;&#39;
        used_workers = {}
        for wt in self.worker_types:
            used_workers[wt] = 0
            for wn, sched in config[wt].items():
                not_na = [1 if cs.v is not None else 0 for _, cs in sched.items()]
                if np.sum(not_na) &gt; 0:
                    used_workers[wt] += 1
        return used_workers

    # Method to return sites accessed in schedule
    # Return: dict with key (x,y) , value access_count: int
    # Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule
    def get_accessed_sites(self, schedule: Dict) -&gt; Tuple[Dict, str]:
        &#39;&#39;&#39;
        # Method to return sites accessed in a schedule
        
                Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule

            Parameters:
                schedule: dict
            
            Return: 
                dict with key (x,y) 

                value access_count: int
        &#39;&#39;&#39;
        accesses = {(vertex.x, vertex.y): 0 for vertex in self.graph.vertices
                    if vertex.vertex_type in self.graph.vertices[0].accessible_types()
                    }
        worker_message = &#34;Log of accesses:\n&#34;

        for wt in self.worker_types:
            for wn, sched in schedule[wt].items():
                t = 0
                while t &lt; len(sched):
                    curr_sched = sched[t]
                    if curr_sched.access is True:
                        t = t + max(curr_sched.v.time_to_acquire - 1, 0)
                        accesses[(curr_sched.v.x, curr_sched.v.y)] += 1
                        worker_message += f&#34;{wt.__str__()} number {wn} accessed &#34; \
                                          f&#34;{curr_sched.v.vertex_type.__str__()} at &#34; \
                                          f&#34;({curr_sched.v.x}, {curr_sched.v.y}) at time step {t}\n&#34;
                    t += 1
        return accesses, worker_message

    # Method to return maximum revenue for graph
    def get_max_revenue(self):
        &#39;&#39;&#39;
        # Method to return maximum revenue for graph

            Arguments:
                None

            Return:
                int, maximum revenue
                    max_revenue = amount_of_sites * single_reward
        &#39;&#39;&#39;
        max_revenue = 0
        for site_type in self.graph.vertices[0].accessible_types():
            amount_of_sites = len(self.graph.get_vertices_type(site_type))
            if amount_of_sites &lt; 1:
                continue
            single_reward = self.graph.get_vertices_type(site_type)[0].reward
            max_revenue += amount_of_sites * single_reward
        return max_revenue

    # True if site v is being accessed at time t in configuration
    # False otherwise
    def site_accessed_at_time(self, v: Vertex, t: int) -&gt; bool:
        &#39;&#39;&#39;
        # Returns bool value to determine if site is being accessed at time t in configuration

            Arguments:
                v: Vertex object, from lyra_graphtool.vertex
                
                t: int, time step value 

            Returns: 
                bool 
                    True if site v is being accessed at time t in configuration, False otherwise
        &#39;&#39;&#39;

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                max_time = len(self.config[wt][wn]) - 1

                if t &gt; max_time:
                    continue
                else:
                    cs = self.config[wt][wn][t]
                    if cs.v is not None:
                        if cs.v == v and cs.access:
                            return True

        return False

    # True if site v is being accessed in configuration
    # False otherwise
    def site_accessed(self, v: Vertex) -&gt; bool:
        &#39;&#39;&#39;
        # Returns bool value to determine if site is being accessed in configuration

            Arguments:
                v: Vertex object, from lyra_graphtool.vertex

            Returns: 
                bool 
                    True if site v is being accessed in configuration, False otherwise
        &#39;&#39;&#39;
        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                for t in range(len(self.config[wt][wn])):
                    cs = self.config[wt][wn][t]
                    if cs.v is not None:
                        if cs.v == v and cs.access:
                            return True
        return False

    # get length of a one worker schedule, how many timesteps was it active?
    @staticmethod
    def get_sched_path_length(sched: Dict) -&gt; int:
        &#39;&#39;&#39;
        # Method to return length of a one worker schedule. Used to determine how many timesteps was the worker active.

            Arguments:
                sched: dict, schedule 

            Returns: 
                int, number of active timesteps
        &#39;&#39;&#39;
        length = 0
        for t, cs in sched.items():
            if cs.v is not None:
                length += 1
        return length

    # True if schedule for single worker is empty
    # False if otherwise
    @staticmethod
    def is_empty(sched: Dict) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if single worker scedule is empty

            Arguments:
                sched: dict, schedule 

            Returns: 
                bool
                    True if schedule for single worker is empty, False if otherwise
        &#39;&#39;&#39;
        for t, cs in sched.items():
            if cs.v is not None:
                return False
        return True

    # Test if schedule is feasible spatially
    #   Note: a schedule is a sequence of Config_Single_Time objects
    #
    # 1. must start at ORIGIN type vertex if origin_flag==True
    # 2. ending vertex followed by None vertices
    # 3. if hire worker again at later time, must start at ORIGIN
    #
    # If origin_flag==False, schedule can start/restart at any vertex
    #
    # sched is Dict with values Config_Single_Time
    #
    def sched_feasible_space(self, sched: Dict, origin_flag=True) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule is spatially feasible

                Criteria
                    1. Must start at ORIGIN type vertex if origin_flag==True
                    2. Ending vertex followed by None vertices
                    3. If hire worker again at later time, must start at ORIGIN
                    Note: If origin_flag==False, schedule can start/restart at any vertex

            Arguments:
                sched: dict, schedule
                    Note: a schedule is a sequence of Config_Single_Time objects
                    
                origin_flag: bool, default True

            Returns: 
                bool
                    True if schedule is spatially feasible, false if otherwise
        &#39;&#39;&#39;
        if len(sched) != self.duration_time:
            raise ValueError(f&#39;Schedule must have {self.duration_time} keys to match duration_time.&#39;)

        if sched[0].v is not None and origin_flag:  # must start at origin if specified
            if sched[0].v.vertex_type != Vertex_Type.ORIGIN:
                return False

        # make sure adjacent vertices are in edge set
        v_prev = sched[0].v  # this may be None
        for t in range(1, self.duration_time):

            if sched[t].v is None:  # current vertex is None
                v_prev = None
                continue

            else:  # actual vertex:  path[t].v is not None

                if v_prev is None:  # vertex following None
                    if origin_flag:
                        if sched[t].v.vertex_type != Vertex_Type.ORIGIN:
                            return False
                        else:
                            v_prev = sched[t].v
                            continue  # ORIGIN following None is ok

                    else:  # any vertex can follow None
                        v_prev = sched[t].v
                        continue

                elif sched[t].v == v_prev:  # can stay at previous location
                    v_prev = sched[t].v
                    continue

                else:  # different location: vertex follows vertex (both not None)

                    # must be an edge in graph
                    e = Edge(v_prev, sched[t].v)
                    if e not in self.graph.edges:
                        return False
                    else:  # it is an edge
                        v_prev = sched[t].v
        return True

    #
    # Test all schedules for spatial feasibility
    #
    def sched_all_feasible_space(self, origin_flag=True) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if ALL schedules are spatially feasible

            Arguments:
                origin_flag: bool, default True

            Returns: 
                bool
                    True if schedule is spatially feasible, false if otherwise
        &#39;&#39;&#39;

        for worker_type in self.worker_types:

            for worker_number in range(len(self.config[worker_type])):

                sched = self.config[worker_type][worker_number]

                feas = self.sched_feasible_space(sched, origin_flag)

                if not feas:
                    return False
        return True

    # Test if a schedule&#39;s access/extract properties are feasible
    #
    # 1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
    # 2. Access constraint - must have Worker &gt;= SITE
    # 3. If accessing, must access site for v.days_to_acquire
    # 4. Cannot access after expiration time
    # 5. Cannot access a site more than once
    #
    def sched_feasible_access_sites(self, sched: Dict, worker_type: Worker_Type) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule&#39;s access/extract properties are feasible

                Criteria
                    1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
                    2. Access constraint - must have Worker &gt;= SITE
                    3. If accessing, must access site for v.days_to_acquire
                    4. Cannot access after expiration time
                    5. Cannot access a site more than once

            Arguments:
                sched: dict, schedule
                    Note: a schedule is a sequence of Config_Single_Time objects
                    
                worker_type: Worker_Type (class), from lyra_graphtool.worker

            Returns: 
                bool
                    True if schedule&#39;s access/extract properties are feasible, False if otherwise
        &#39;&#39;&#39;

        sites_accessed = []
        t = 0
        while t &lt; len(sched):

            v = sched[t].v
            acc = sched[t].access

            if v is None:
                if acc is not False:
                    return False
                else:
                    t += 1
                    continue

            if v.vertex_type == Vertex_Type.BASIC or v.vertex_type ==  Vertex_Type.ORIGIN:
                if acc is True:
                    return False
                else:
                    t += 1

            else:  # default - this vertex is a site
                if acc is True:

                    # test if sites was previously accessed
                    if v in sites_accessed:
                        return False
                    else:
                        sites_accessed.append(v)

                    # test if worker allowed to access
                    if self.get_worker(worker_type).access(v) is False:
                        return False

                    # test if accessing after expire
                    if v.expiration_time is not None:
                        if t &gt;= v.expiration_time:
                            return False

                    # set future times to same vertex with access=True
                    for t_off in range(1, v.time_to_acquire):
                        if t + t_off &lt; self.duration_time:
                            s2 = sched[t + t_off]
                            v2, acc2 = s2.v, s2.access
                        else:  # ran out of time: infeasible
                            return False

                        if v2 is None:
                            return False
                        elif v2 != v or acc2 is False:
                            return False

                    t += v.time_to_acquire
                else:
                    t += 1

        return True

    #
    # Test all schedules for access feasibility
    #
    # 1. Only one worker can access a specific site at a single point in time
    # 2. Once a site has been accessed, it can no longer be accessed at subsequent times
    #
    # noinspection SpellCheckingInspection
    def sched_all_feasible_access_sites(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if schedule&#39;s access properties are feasible

                Criteria
                    1. Only one worker can access a specific site at a single point in time
                    2. Once a site has been accessed, it can no longer be accessed at subsequent times

            Arguments:
                None

            Return: 
                bool
                    True if schedule&#39;s access properties are feasible, False if otherwise
        &#39;&#39;&#39;

        # check schedule feasibility for each individual worker
        for worker_type in self.worker_types:

            for worker_number in range(len(self.config[worker_type])):

                sched = self.config[worker_type][worker_number]

                feas = self.sched_feasible_access_sites(sched, worker_type)

                if not feas:
                    return False

        # check that each site is accessed no more than one time
        accesses, _ = self.get_accessed_sites(self.config)

        if max(accesses.values()) &gt; 1:
            return False

        return True

    #
    # Calculate cost of a single-worker schedule
    #
    # sched is a dict with key=time, value=Config_Single_Time
    #   (for a single worker)
    #
    @staticmethod
    def cost_sched(sched: Dict, worker: Worker) -&gt; float:
        &#39;&#39;&#39;
        # Calculate the cost of a single-worker schedule

            Arguments:
                sched: dict,
                    sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                    worker: Worker (class), from lyra_graphtool.worker

            Returns:
                float, cost value of a single worker schedule
        &#39;&#39;&#39;

        cost_sched = 0
        for t in range(len(sched)):
            v = sched[t].v
            access = sched[t].access

            if v is None:  # worker not on payroll
                continue

            else:  # worker is on payroll

                cost_base = worker.worker_cost_rate
                cost = cost_base

                if access is True:

                    # get multipliers
                    mult_time = v.mult_time
                    mult_time_start = v.mult_time_active[0]
                    mult_time_end = v.mult_time_active[1]
                    mult_worker = v.mult_worker

                    # cost for time multiplier
                    if mult_time_start is not None and mult_time_end is not None:
                        if mult_time_start &lt;= t &lt;= mult_time_end:
                            cost += (mult_time - 1) * cost_base

                    # cost for site multiplier
                    wt = worker.worker_type
                    if wt in mult_worker.keys():
                        cost += (mult_worker[wt] - 1) * cost_base

                cost_sched += cost

        return cost_sched

    #
    # Calculate cost of entire configuration
    #
    # sched is a dict with key=time, value=Config_Single_Time
    #   (for a single worker)
    #
    # NOTE: default worker_cost_rate is used for each worker type
    def cost(self) -&gt; float:
        &#39;&#39;&#39;
        # Calculate the cost of the entire configuration
                Note: default worker_cost_rate is used for each worker type

            Arguments:
                None

            Returns:
                float, cost value of entire configuration
        &#39;&#39;&#39;

        cost_config = 0

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                sched = self.config[wt][wn]
                worker = self.get_worker(wt)
                cost_config += self.cost_sched(sched, worker)

        return cost_config

    # Budget Feasibility of Configuration
    def budget_feasible(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to determine if budget is feasible for configuration. If Cost &lt;= Budget then Feasible else Not Feasible

            Arguments:
                None

            Returns:
                bool
                    True if budget is feasible, False if otherwise
        &#39;&#39;&#39;

        if self.cost() &lt;= self.budget:
            return True
        else:
            return False

    # test overall feasibility of config using above methods
    def feasible(self) -&gt; bool:
        &#39;&#39;&#39;
        # Method to test the overall feasibily using sched_all_feasibility_space()
        , sched_all_feasible_access_sites(), and budget_feasible()

            Arguments:
                None

            Returns:
                bool
                    True if all functions are feasible, False if otherwise
        &#39;&#39;&#39;

        feas_space = self.sched_all_feasible_space()
        feas_access = self.sched_all_feasible_access_sites()
        feas_budget = self.budget_feasible()

        feas = feas_space and feas_access and feas_budget

        return feas

    # calculate returns/revenue from schedule for single worker
    #
    # sched should be tested for feasibility by sched_feasible_access_sites
    # before calling this funciton
    #
    # Note: revenue depends on worker_type
    @staticmethod
    def sched_revenue(sched: Dict):
        &#39;&#39;&#39;
        # Method to calculate revenue from schedule for single worker
                Note: Sched should be tested for feasibility by sched_feasible_access_sites
                before calling this function

            Arguments:
                sched: dict, schedule
                    sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                    worker: Worker (class), from lyra_graphtool.worker

            Returns:
                int, revenue (depends on worker_type)
        &#39;&#39;&#39;

        revenue = 0
        t = 0
        while t &lt; len(sched):

            v = sched[t].v
            acc = sched[t].access

            if acc is False:  # this covers non-SITEx vertices and .v = None
                t += 1
                continue

            # at SITEx vertex AND accessing
            revenue += v.reward
            t += v.time_to_acquire

        return revenue

    # calculate returns/revenue for entire configuration
    #
    # sched should be tested for feasibility by sched_feasible_access_sites
    # before calling this funciton
    #
    def revenue(self):
        &#39;&#39;&#39;
        # Method to calculate revenue from schedule for entire configuration
                Note: Sched should be tested for feasibility by sched_feasible_access_sites
                before calling this function

            Arguments:
                None

            Returns:
                int, revenue value for entire configuration
        &#39;&#39;&#39;

        revenue = 0

        for wt in self.worker_types:
            for wn in range(len(self.config[wt])):
                sched = self.config[wt][wn]
                revenue += self.sched_revenue(sched)

        return revenue

    # save configuration to file
    def save(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Save configuration file to pickle format

            Arguments:
                filename: str, filepath for file to be saved

            Returns:
                None
        &#39;&#39;&#39;
        fn = file_name

        with open(fn, &#39;wb&#39;) as f:
            pickle.dump(self, f)

    # save Configuration.config schedule dictionary to json
    def save_to_json(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Save configuration schedule dictionary to json format

            Arguments:
                filename: str, filepath for file to be saved

            Returns:
                None
        &#39;&#39;&#39;
        config_json = {}
        for wt in self.worker_types:
            config_json[wt] = {}
            for wn in range(len(self.config[wt])):
                config_json[wt][wn] = {}
                sched = self.config[wt][wn]
                for t in range(len(sched)):
                    cs = sched[t]
                    v, access = cs.v, cs.access
                    if v is None:
                        cs_basic = [&#39;None&#39;, cs.access]
                    else:
                        cs_basic = [float(v.x), float(v.y), cs.access]
                    config_json[wt][wn][t] = cs_basic
        # save to json
        with open(file_name, &#39;w&#39;) as f:
            json.dump(config_json, f)

    # load json config into Configuration.config
    def load_from_json(self, file_name: str) -&gt; None:
        &#39;&#39;&#39;
        # Load configuration schedule dictionary from json format into Configuration.config

            Arguments:
                filename: str, json filepath to import

            Returns:
                None
        &#39;&#39;&#39;

        def jsonKeys2int(x):
            if isinstance(x, dict):
                return {int(k): v for k, v in x.items()}
            return x

        with open(file_name) as f:
            d = json.load(f, object_hook=jsonKeys2int)

        config = {}
        for wt in self.worker_types:
            config[wt] = {}
            for wn in range(len(self.config[wt])):
                config[wt][wn] = {}
                sched = self.config[wt][wn]
                for t in range(len(sched)):
                    if wt in d.keys():
                        if wn in d[wt].keys():
                            if t in d[wt][wn].keys():
                                csj = d[wt][wn][t]
                                if csj[0] == &#39;None&#39;:
                                    config[wt][wn][t] = Config_Single_Time()
                                else:
                                    msg_err = f&#39;json dictionary in file {file_name} must have triple (float,float,bool) &#39; + \
                                              f&#39;at index {[wt, wn, t]}.&#39;
                                    if len(csj) != 3:
                                        raise ValueError(msg_err)
                                    x, y, access = csj[0], csj[1], csj[2]
                                    if not isinstance(x, float) or not isinstance(y, float) or not isinstance(access,
                                                                                                              bool):
                                        raise ValueError(msg_err)
                                    v = self.graph.get_vertex_xy(x, y)
                                    if v is None:
                                        raise ValueError(
                                            f&#39;Vertex in json file {file_name} with coords {(x, y)} not found in graph.&#39;)

                                    config[wt][wn][t] = Config_Single_Time(v, access)

        self.config = config  # no errors, copy config

    # override python deepcopy function, which is very slow
    # 1. use pickle.dumps() to write object to binary file
    # 2. use pickle.loads() to read binary file into new object
    # Argument
    #        memo: dummy variable to match format of deepcopy from copy library
    # Returns
    #        Node: deepcopy of original configuration
    #
    def __deepcopy__(self, memo):
        return pickle.loads(pickle.dumps(self, -1))  # -1 uses most recent protocol</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="lyra_graphtool.configuration.Configuration.cost_sched"><code class="name flex">
<span>def <span class="ident">cost_sched</span></span>(<span>sched: Dict, worker: <a title="lyra_graphtool.worker.Worker" href="worker.html#lyra_graphtool.worker.Worker">Worker</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h1 id="calculate-the-cost-of-a-single-worker-schedule">Calculate the cost of a single-worker schedule</h1>
<pre><code>Arguments:
    sched: dict,
        sched is a dict with key=time, value=Config_Single_Time (for a single worker)
        worker: Worker (class), from lyra_graphtool.worker

Returns:
    float, cost value of a single worker schedule
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def cost_sched(sched: Dict, worker: Worker) -&gt; float:
    &#39;&#39;&#39;
    # Calculate the cost of a single-worker schedule

        Arguments:
            sched: dict,
                sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                worker: Worker (class), from lyra_graphtool.worker

        Returns:
            float, cost value of a single worker schedule
    &#39;&#39;&#39;

    cost_sched = 0
    for t in range(len(sched)):
        v = sched[t].v
        access = sched[t].access

        if v is None:  # worker not on payroll
            continue

        else:  # worker is on payroll

            cost_base = worker.worker_cost_rate
            cost = cost_base

            if access is True:

                # get multipliers
                mult_time = v.mult_time
                mult_time_start = v.mult_time_active[0]
                mult_time_end = v.mult_time_active[1]
                mult_worker = v.mult_worker

                # cost for time multiplier
                if mult_time_start is not None and mult_time_end is not None:
                    if mult_time_start &lt;= t &lt;= mult_time_end:
                        cost += (mult_time - 1) * cost_base

                # cost for site multiplier
                wt = worker.worker_type
                if wt in mult_worker.keys():
                    cost += (mult_worker[wt] - 1) * cost_base

            cost_sched += cost

    return cost_sched</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_sched_path_length"><code class="name flex">
<span>def <span class="ident">get_sched_path_length</span></span>(<span>sched: Dict) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-return-length-of-a-one-worker-schedule-used-to-determine-how-many-timesteps-was-the-worker-active">Method to return length of a one worker schedule. Used to determine how many timesteps was the worker active.</h1>
<pre><code>Arguments:
    sched: dict, schedule

Returns: 
    int, number of active timesteps
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_sched_path_length(sched: Dict) -&gt; int:
    &#39;&#39;&#39;
    # Method to return length of a one worker schedule. Used to determine how many timesteps was the worker active.

        Arguments:
            sched: dict, schedule 

        Returns: 
            int, number of active timesteps
    &#39;&#39;&#39;
    length = 0
    for t, cs in sched.items():
        if cs.v is not None:
            length += 1
    return length</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>sched: Dict) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-single-worker-scedule-is-empty">Method to determine if single worker scedule is empty</h1>
<pre><code>Arguments:
    sched: dict, schedule

Returns: 
    bool
        True if schedule for single worker is empty, False if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_empty(sched: Dict) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if single worker scedule is empty

        Arguments:
            sched: dict, schedule 

        Returns: 
            bool
                True if schedule for single worker is empty, False if otherwise
    &#39;&#39;&#39;
    for t, cs in sched.items():
        if cs.v is not None:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_info"><code class="name flex">
<span>def <span class="ident">sched_info</span></span>(<span>sched: Dict) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><h1 id="display-the-info-of-the-given-schedule">Display the info of the given schedule</h1>
<pre><code>Arguments:

    sched: dict, schedule

Return:

    list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sched_info(sched: Dict) -&gt; List:
    &#39;&#39;&#39;
    # Display the info of the given schedule

        Arguments:

            sched: dict, schedule

        Return:
        
            list
    &#39;&#39;&#39;
    info = []
    for t in range(len(sched)):
        i = sched[t].info()  # [ (x,y), vtype, access ]
        info.append(f&#39;[t={t}, ({i[0][0]},{i[0][1]}), vtype={i[1]}, acc={i[2]} ]&#39;)
    return info</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_revenue"><code class="name flex">
<span>def <span class="ident">sched_revenue</span></span>(<span>sched: Dict)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-calculate-revenue-from-schedule-for-single-worker">Method to calculate revenue from schedule for single worker</h1>
<pre><code>    Note: Sched should be tested for feasibility by sched_feasible_access_sites
    before calling this function

Arguments:
    sched: dict, schedule
        sched is a dict with key=time, value=Config_Single_Time (for a single worker)
        worker: Worker (class), from lyra_graphtool.worker

Returns:
    int, revenue (depends on worker_type)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sched_revenue(sched: Dict):
    &#39;&#39;&#39;
    # Method to calculate revenue from schedule for single worker
            Note: Sched should be tested for feasibility by sched_feasible_access_sites
            before calling this function

        Arguments:
            sched: dict, schedule
                sched is a dict with key=time, value=Config_Single_Time (for a single worker)
                worker: Worker (class), from lyra_graphtool.worker

        Returns:
            int, revenue (depends on worker_type)
    &#39;&#39;&#39;

    revenue = 0
    t = 0
    while t &lt; len(sched):

        v = sched[t].v
        acc = sched[t].access

        if acc is False:  # this covers non-SITEx vertices and .v = None
            t += 1
            continue

        # at SITEx vertex AND accessing
        revenue += v.reward
        t += v.time_to_acquire

    return revenue</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lyra_graphtool.configuration.Configuration.add_sched"><code class="name flex">
<span>def <span class="ident">add_sched</span></span>(<span>self, wt: <a title="lyra_graphtool.worker.Worker_Type" href="worker.html#lyra_graphtool.worker.Worker_Type">Worker_Type</a>, wn: int, sched: Dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h1 id="add-a-schedule-deepcopy-to-configuration-at-wt-wn">Add a schedule (deepcopy) to configuration at wt, wn</h1>
<pre><code>Arguments:

    wt: Worker_Type (class), int

    wn: int, number of workers

    sched: dict, schedule

Return:

    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sched(self, wt: Worker_Type, wn: int, sched: Dict) -&gt; None:
    &#39;&#39;&#39;    
    # Add a schedule (deepcopy) to configuration at wt, wn
    
        Arguments:

            wt: Worker_Type (class), int

            wn: int, number of workers
            
            sched: dict, schedule
        
        Return:

            None
    &#39;&#39;&#39;

    if len(sched) == self.duration_time:
        self.config[wt][wn] = deepcopy(sched)
    else:
        raise ValueError(f&#39;Schedule must have length {self.duration_time}.&#39;)</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.budget_feasible"><code class="name flex">
<span>def <span class="ident">budget_feasible</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-budget-is-feasible-for-configuration-if-cost-budget-then-feasible-else-not-feasible">Method to determine if budget is feasible for configuration. If Cost &lt;= Budget then Feasible else Not Feasible</h1>
<pre><code>Arguments:
    None

Returns:
    bool
        True if budget is feasible, False if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def budget_feasible(self) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if budget is feasible for configuration. If Cost &lt;= Budget then Feasible else Not Feasible

        Arguments:
            None

        Returns:
            bool
                True if budget is feasible, False if otherwise
    &#39;&#39;&#39;

    if self.cost() &lt;= self.budget:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.cost"><code class="name flex">
<span>def <span class="ident">cost</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h1 id="calculate-the-cost-of-the-entire-configuration">Calculate the cost of the entire configuration</h1>
<pre><code>    Note: default worker_cost_rate is used for each worker type

Arguments:
    None

Returns:
    float, cost value of entire configuration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cost(self) -&gt; float:
    &#39;&#39;&#39;
    # Calculate the cost of the entire configuration
            Note: default worker_cost_rate is used for each worker type

        Arguments:
            None

        Returns:
            float, cost value of entire configuration
    &#39;&#39;&#39;

    cost_config = 0

    for wt in self.worker_types:
        for wn in range(len(self.config[wt])):
            sched = self.config[wt][wn]
            worker = self.get_worker(wt)
            cost_config += self.cost_sched(sched, worker)

    return cost_config</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.feasible"><code class="name flex">
<span>def <span class="ident">feasible</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-test-the-overall-feasibily-using-sched_all_feasibility_space">Method to test the overall feasibily using sched_all_feasibility_space()</h1>
<p>, sched_all_feasible_access_sites(), and budget_feasible()</p>
<pre><code>Arguments:
    None

Returns:
    bool
        True if all functions are feasible, False if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feasible(self) -&gt; bool:
    &#39;&#39;&#39;
    # Method to test the overall feasibily using sched_all_feasibility_space()
    , sched_all_feasible_access_sites(), and budget_feasible()

        Arguments:
            None

        Returns:
            bool
                True if all functions are feasible, False if otherwise
    &#39;&#39;&#39;

    feas_space = self.sched_all_feasible_space()
    feas_access = self.sched_all_feasible_access_sites()
    feas_budget = self.budget_feasible()

    feas = feas_space and feas_access and feas_budget

    return feas</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_accessed_sites"><code class="name flex">
<span>def <span class="ident">get_accessed_sites</span></span>(<span>self, schedule: Dict) ‑> Tuple[Dict, str]</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-return-sites-accessed-in-a-schedule">Method to return sites accessed in a schedule</h1>
<pre><code>    Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule

Parameters:
    schedule: dict

Return: 
    dict with key (x,y)

    value access_count: int
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_accessed_sites(self, schedule: Dict) -&gt; Tuple[Dict, str]:
    &#39;&#39;&#39;
    # Method to return sites accessed in a schedule
    
            Note: access_count = 1 means the site v appeared v.time_to_acquire adjacent times in a schedule

        Parameters:
            schedule: dict
        
        Return: 
            dict with key (x,y) 

            value access_count: int
    &#39;&#39;&#39;
    accesses = {(vertex.x, vertex.y): 0 for vertex in self.graph.vertices
                if vertex.vertex_type in self.graph.vertices[0].accessible_types()
                }
    worker_message = &#34;Log of accesses:\n&#34;

    for wt in self.worker_types:
        for wn, sched in schedule[wt].items():
            t = 0
            while t &lt; len(sched):
                curr_sched = sched[t]
                if curr_sched.access is True:
                    t = t + max(curr_sched.v.time_to_acquire - 1, 0)
                    accesses[(curr_sched.v.x, curr_sched.v.y)] += 1
                    worker_message += f&#34;{wt.__str__()} number {wn} accessed &#34; \
                                      f&#34;{curr_sched.v.vertex_type.__str__()} at &#34; \
                                      f&#34;({curr_sched.v.x}, {curr_sched.v.y}) at time step {t}\n&#34;
                t += 1
    return accesses, worker_message</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_current_workers"><code class="name flex">
<span>def <span class="ident">get_current_workers</span></span>(<span>self, config: Dict) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-returning-dict-of-workers-used-in-configuration">Method returning dict of workers used in configuration</h1>
<pre><code>Arguments:
    config: dict

Returns: 
    dict
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_workers(self, config: Dict) -&gt; Dict:
    &#39;&#39;&#39;
    # Method returning dict of workers used in configuration

        Arguments:
            config: dict

        Returns: 
            dict
    &#39;&#39;&#39;
    used_workers = {}
    for wt in self.worker_types:
        used_workers[wt] = 0
        for wn, sched in config[wt].items():
            not_na = [1 if cs.v is not None else 0 for _, cs in sched.items()]
            if np.sum(not_na) &gt; 0:
                used_workers[wt] += 1
    return used_workers</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_max_revenue"><code class="name flex">
<span>def <span class="ident">get_max_revenue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-return-maximum-revenue-for-graph">Method to return maximum revenue for graph</h1>
<pre><code>Arguments:
    None

Return:
    int, maximum revenue
        max_revenue = amount_of_sites * single_reward
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_revenue(self):
    &#39;&#39;&#39;
    # Method to return maximum revenue for graph

        Arguments:
            None

        Return:
            int, maximum revenue
                max_revenue = amount_of_sites * single_reward
    &#39;&#39;&#39;
    max_revenue = 0
    for site_type in self.graph.vertices[0].accessible_types():
        amount_of_sites = len(self.graph.get_vertices_type(site_type))
        if amount_of_sites &lt; 1:
            continue
        single_reward = self.graph.get_vertices_type(site_type)[0].reward
        max_revenue += amount_of_sites * single_reward
    return max_revenue</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_vertices_start"><code class="name flex">
<span>def <span class="ident">get_vertices_start</span></span>(<span>self) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><h1 id="get-list-the-vertices-from-which-a-workers-path-must-start">Get list the vertices from which a worker's path must start</h1>
<pre><code>    Note: this allows for generalizations - should avoid hard-coding
        constraints outside this class (ie by solvers)

Arguments:
    None

Return:
    list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertices_start(self) -&gt; List:
    &#39;&#39;&#39;
    # Get list the vertices from which a worker&#39;s path must start
        
            Note: this allows for generalizations - should avoid hard-coding
                constraints outside this class (ie by solvers)
        
        Arguments:
            None
        
        Return:
            list
    &#39;&#39;&#39;

    verts_graph = self.graph.get_vertices_type(Vertex_Type.ORIGIN)

    verts_start = []
    for v in verts_graph:
        verts_start.append(deepcopy(v))

    return verts_start</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.get_worker"><code class="name flex">
<span>def <span class="ident">get_worker</span></span>(<span>self, wt: <a title="lyra_graphtool.worker.Worker_Type" href="worker.html#lyra_graphtool.worker.Worker_Type">Worker_Type</a>) ‑> <a title="lyra_graphtool.worker.Worker" href="worker.html#lyra_graphtool.worker.Worker">Worker</a></span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-return-worker-object-that-has-rates-compliant-with-configuration">Method to return Worker object, that has rates compliant with configuration</h1>
<pre><code>Arguments:
    wt: int, Worker_Type(class)


Return:
    Worker(class)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_worker(self, wt: Worker_Type) -&gt; Worker:
    &#39;&#39;&#39;
    # Method to return Worker object, that has rates compliant with configuration

        Arguments:
            wt: int, Worker_Type(class)\n

        Return:
            Worker(class)
    &#39;&#39;&#39;
    return Worker(wt, rates=self.worker_cost_rate)</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.load_from_json"><code class="name flex">
<span>def <span class="ident">load_from_json</span></span>(<span>self, file_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h1 id="load-configuration-schedule-dictionary-from-json-format-into-configurationconfig">Load configuration schedule dictionary from json format into Configuration.config</h1>
<pre><code>Arguments:
    filename: str, json filepath to import

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_json(self, file_name: str) -&gt; None:
    &#39;&#39;&#39;
    # Load configuration schedule dictionary from json format into Configuration.config

        Arguments:
            filename: str, json filepath to import

        Returns:
            None
    &#39;&#39;&#39;

    def jsonKeys2int(x):
        if isinstance(x, dict):
            return {int(k): v for k, v in x.items()}
        return x

    with open(file_name) as f:
        d = json.load(f, object_hook=jsonKeys2int)

    config = {}
    for wt in self.worker_types:
        config[wt] = {}
        for wn in range(len(self.config[wt])):
            config[wt][wn] = {}
            sched = self.config[wt][wn]
            for t in range(len(sched)):
                if wt in d.keys():
                    if wn in d[wt].keys():
                        if t in d[wt][wn].keys():
                            csj = d[wt][wn][t]
                            if csj[0] == &#39;None&#39;:
                                config[wt][wn][t] = Config_Single_Time()
                            else:
                                msg_err = f&#39;json dictionary in file {file_name} must have triple (float,float,bool) &#39; + \
                                          f&#39;at index {[wt, wn, t]}.&#39;
                                if len(csj) != 3:
                                    raise ValueError(msg_err)
                                x, y, access = csj[0], csj[1], csj[2]
                                if not isinstance(x, float) or not isinstance(y, float) or not isinstance(access,
                                                                                                          bool):
                                    raise ValueError(msg_err)
                                v = self.graph.get_vertex_xy(x, y)
                                if v is None:
                                    raise ValueError(
                                        f&#39;Vertex in json file {file_name} with coords {(x, y)} not found in graph.&#39;)

                                config[wt][wn][t] = Config_Single_Time(v, access)

    self.config = config  # no errors, copy config</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.revenue"><code class="name flex">
<span>def <span class="ident">revenue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-calculate-revenue-from-schedule-for-entire-configuration">Method to calculate revenue from schedule for entire configuration</h1>
<pre><code>    Note: Sched should be tested for feasibility by sched_feasible_access_sites
    before calling this function

Arguments:
    None

Returns:
    int, revenue value for entire configuration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revenue(self):
    &#39;&#39;&#39;
    # Method to calculate revenue from schedule for entire configuration
            Note: Sched should be tested for feasibility by sched_feasible_access_sites
            before calling this function

        Arguments:
            None

        Returns:
            int, revenue value for entire configuration
    &#39;&#39;&#39;

    revenue = 0

    for wt in self.worker_types:
        for wn in range(len(self.config[wt])):
            sched = self.config[wt][wn]
            revenue += self.sched_revenue(sched)

    return revenue</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h1 id="save-configuration-file-to-pickle-format">Save configuration file to pickle format</h1>
<pre><code>Arguments:
    filename: str, filepath for file to be saved

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name: str) -&gt; None:
    &#39;&#39;&#39;
    # Save configuration file to pickle format

        Arguments:
            filename: str, filepath for file to be saved

        Returns:
            None
    &#39;&#39;&#39;
    fn = file_name

    with open(fn, &#39;wb&#39;) as f:
        pickle.dump(self, f)</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.save_to_json"><code class="name flex">
<span>def <span class="ident">save_to_json</span></span>(<span>self, file_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h1 id="save-configuration-schedule-dictionary-to-json-format">Save configuration schedule dictionary to json format</h1>
<pre><code>Arguments:
    filename: str, filepath for file to be saved

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to_json(self, file_name: str) -&gt; None:
    &#39;&#39;&#39;
    # Save configuration schedule dictionary to json format

        Arguments:
            filename: str, filepath for file to be saved

        Returns:
            None
    &#39;&#39;&#39;
    config_json = {}
    for wt in self.worker_types:
        config_json[wt] = {}
        for wn in range(len(self.config[wt])):
            config_json[wt][wn] = {}
            sched = self.config[wt][wn]
            for t in range(len(sched)):
                cs = sched[t]
                v, access = cs.v, cs.access
                if v is None:
                    cs_basic = [&#39;None&#39;, cs.access]
                else:
                    cs_basic = [float(v.x), float(v.y), cs.access]
                config_json[wt][wn][t] = cs_basic
    # save to json
    with open(file_name, &#39;w&#39;) as f:
        json.dump(config_json, f)</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_all_feasible_access_sites"><code class="name flex">
<span>def <span class="ident">sched_all_feasible_access_sites</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-schedules-access-properties-are-feasible">Method to determine if schedule's access properties are feasible</h1>
<pre><code>    Criteria
        1. Only one worker can access a specific site at a single point in time
        2. Once a site has been accessed, it can no longer be accessed at subsequent times

Arguments:
    None

Return: 
    bool
        True if schedule's access properties are feasible, False if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sched_all_feasible_access_sites(self) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if schedule&#39;s access properties are feasible

            Criteria
                1. Only one worker can access a specific site at a single point in time
                2. Once a site has been accessed, it can no longer be accessed at subsequent times

        Arguments:
            None

        Return: 
            bool
                True if schedule&#39;s access properties are feasible, False if otherwise
    &#39;&#39;&#39;

    # check schedule feasibility for each individual worker
    for worker_type in self.worker_types:

        for worker_number in range(len(self.config[worker_type])):

            sched = self.config[worker_type][worker_number]

            feas = self.sched_feasible_access_sites(sched, worker_type)

            if not feas:
                return False

    # check that each site is accessed no more than one time
    accesses, _ = self.get_accessed_sites(self.config)

    if max(accesses.values()) &gt; 1:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_all_feasible_space"><code class="name flex">
<span>def <span class="ident">sched_all_feasible_space</span></span>(<span>self, origin_flag=True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-all-schedules-are-spatially-feasible">Method to determine if ALL schedules are spatially feasible</h1>
<pre><code>Arguments:
    origin_flag: bool, default True

Returns: 
    bool
        True if schedule is spatially feasible, false if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sched_all_feasible_space(self, origin_flag=True) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if ALL schedules are spatially feasible

        Arguments:
            origin_flag: bool, default True

        Returns: 
            bool
                True if schedule is spatially feasible, false if otherwise
    &#39;&#39;&#39;

    for worker_type in self.worker_types:

        for worker_number in range(len(self.config[worker_type])):

            sched = self.config[worker_type][worker_number]

            feas = self.sched_feasible_space(sched, origin_flag)

            if not feas:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_feasible_access_sites"><code class="name flex">
<span>def <span class="ident">sched_feasible_access_sites</span></span>(<span>self, sched: Dict, worker_type: <a title="lyra_graphtool.worker.Worker_Type" href="worker.html#lyra_graphtool.worker.Worker_Type">Worker_Type</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-schedules-accessextract-properties-are-feasible">Method to determine if schedule's access/extract properties are feasible</h1>
<pre><code>    Criteria
        1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
        2. Access constraint - must have Worker &gt;= SITE
        3. If accessing, must access site for v.days_to_acquire
        4. Cannot access after expiration time
        5. Cannot access a site more than once

Arguments:
    sched: dict, schedule
        Note: a schedule is a sequence of Config_Single_Time objects

    worker_type: Worker_Type (class), from lyra_graphtool.worker

Returns: 
    bool
        True if schedule's access/extract properties are feasible, False if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sched_feasible_access_sites(self, sched: Dict, worker_type: Worker_Type) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if schedule&#39;s access/extract properties are feasible

            Criteria
                1. Can only access site - cannot access a non-site vertex as BASIC, ORIGIN
                2. Access constraint - must have Worker &gt;= SITE
                3. If accessing, must access site for v.days_to_acquire
                4. Cannot access after expiration time
                5. Cannot access a site more than once

        Arguments:
            sched: dict, schedule
                Note: a schedule is a sequence of Config_Single_Time objects
                
            worker_type: Worker_Type (class), from lyra_graphtool.worker

        Returns: 
            bool
                True if schedule&#39;s access/extract properties are feasible, False if otherwise
    &#39;&#39;&#39;

    sites_accessed = []
    t = 0
    while t &lt; len(sched):

        v = sched[t].v
        acc = sched[t].access

        if v is None:
            if acc is not False:
                return False
            else:
                t += 1
                continue

        if v.vertex_type == Vertex_Type.BASIC or v.vertex_type ==  Vertex_Type.ORIGIN:
            if acc is True:
                return False
            else:
                t += 1

        else:  # default - this vertex is a site
            if acc is True:

                # test if sites was previously accessed
                if v in sites_accessed:
                    return False
                else:
                    sites_accessed.append(v)

                # test if worker allowed to access
                if self.get_worker(worker_type).access(v) is False:
                    return False

                # test if accessing after expire
                if v.expiration_time is not None:
                    if t &gt;= v.expiration_time:
                        return False

                # set future times to same vertex with access=True
                for t_off in range(1, v.time_to_acquire):
                    if t + t_off &lt; self.duration_time:
                        s2 = sched[t + t_off]
                        v2, acc2 = s2.v, s2.access
                    else:  # ran out of time: infeasible
                        return False

                    if v2 is None:
                        return False
                    elif v2 != v or acc2 is False:
                        return False

                t += v.time_to_acquire
            else:
                t += 1

    return True</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.sched_feasible_space"><code class="name flex">
<span>def <span class="ident">sched_feasible_space</span></span>(<span>self, sched: Dict, origin_flag=True) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="method-to-determine-if-schedule-is-spatially-feasible">Method to determine if schedule is spatially feasible</h1>
<pre><code>    Criteria
        1. Must start at ORIGIN type vertex if origin_flag==True
        2. Ending vertex followed by None vertices
        3. If hire worker again at later time, must start at ORIGIN
        Note: If origin_flag==False, schedule can start/restart at any vertex

Arguments:
    sched: dict, schedule
        Note: a schedule is a sequence of Config_Single_Time objects

    origin_flag: bool, default True

Returns: 
    bool
        True if schedule is spatially feasible, false if otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sched_feasible_space(self, sched: Dict, origin_flag=True) -&gt; bool:
    &#39;&#39;&#39;
    # Method to determine if schedule is spatially feasible

            Criteria
                1. Must start at ORIGIN type vertex if origin_flag==True
                2. Ending vertex followed by None vertices
                3. If hire worker again at later time, must start at ORIGIN
                Note: If origin_flag==False, schedule can start/restart at any vertex

        Arguments:
            sched: dict, schedule
                Note: a schedule is a sequence of Config_Single_Time objects
                
            origin_flag: bool, default True

        Returns: 
            bool
                True if schedule is spatially feasible, false if otherwise
    &#39;&#39;&#39;
    if len(sched) != self.duration_time:
        raise ValueError(f&#39;Schedule must have {self.duration_time} keys to match duration_time.&#39;)

    if sched[0].v is not None and origin_flag:  # must start at origin if specified
        if sched[0].v.vertex_type != Vertex_Type.ORIGIN:
            return False

    # make sure adjacent vertices are in edge set
    v_prev = sched[0].v  # this may be None
    for t in range(1, self.duration_time):

        if sched[t].v is None:  # current vertex is None
            v_prev = None
            continue

        else:  # actual vertex:  path[t].v is not None

            if v_prev is None:  # vertex following None
                if origin_flag:
                    if sched[t].v.vertex_type != Vertex_Type.ORIGIN:
                        return False
                    else:
                        v_prev = sched[t].v
                        continue  # ORIGIN following None is ok

                else:  # any vertex can follow None
                    v_prev = sched[t].v
                    continue

            elif sched[t].v == v_prev:  # can stay at previous location
                v_prev = sched[t].v
                continue

            else:  # different location: vertex follows vertex (both not None)

                # must be an edge in graph
                e = Edge(v_prev, sched[t].v)
                if e not in self.graph.edges:
                    return False
                else:  # it is an edge
                    v_prev = sched[t].v
    return True</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.site_accessed"><code class="name flex">
<span>def <span class="ident">site_accessed</span></span>(<span>self, v: <a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="returns-bool-value-to-determine-if-site-is-being-accessed-in-configuration">Returns bool value to determine if site is being accessed in configuration</h1>
<pre><code>Arguments:
    v: Vertex object, from lyra_graphtool.vertex

Returns: 
    bool 
        True if site v is being accessed in configuration, False otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def site_accessed(self, v: Vertex) -&gt; bool:
    &#39;&#39;&#39;
    # Returns bool value to determine if site is being accessed in configuration

        Arguments:
            v: Vertex object, from lyra_graphtool.vertex

        Returns: 
            bool 
                True if site v is being accessed in configuration, False otherwise
    &#39;&#39;&#39;
    for wt in self.worker_types:
        for wn in range(len(self.config[wt])):
            for t in range(len(self.config[wt][wn])):
                cs = self.config[wt][wn][t]
                if cs.v is not None:
                    if cs.v == v and cs.access:
                        return True
    return False</code></pre>
</details>
</dd>
<dt id="lyra_graphtool.configuration.Configuration.site_accessed_at_time"><code class="name flex">
<span>def <span class="ident">site_accessed_at_time</span></span>(<span>self, v: <a title="lyra_graphtool.vertex.Vertex" href="vertex.html#lyra_graphtool.vertex.Vertex">Vertex</a>, t: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h1 id="returns-bool-value-to-determine-if-site-is-being-accessed-at-time-t-in-configuration">Returns bool value to determine if site is being accessed at time t in configuration</h1>
<pre><code>Arguments:
    v: Vertex object, from lyra_graphtool.vertex

    t: int, time step value

Returns: 
    bool 
        True if site v is being accessed at time t in configuration, False otherwise
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def site_accessed_at_time(self, v: Vertex, t: int) -&gt; bool:
    &#39;&#39;&#39;
    # Returns bool value to determine if site is being accessed at time t in configuration

        Arguments:
            v: Vertex object, from lyra_graphtool.vertex
            
            t: int, time step value 

        Returns: 
            bool 
                True if site v is being accessed at time t in configuration, False otherwise
    &#39;&#39;&#39;

    for wt in self.worker_types:
        for wn in range(len(self.config[wt])):
            max_time = len(self.config[wt][wn]) - 1

            if t &gt; max_time:
                continue
            else:
                cs = self.config[wt][wn][t]
                if cs.v is not None:
                    if cs.v == v and cs.access:
                        return True

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lyra_graphtool" href="index.html">lyra_graphtool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lyra_graphtool.configuration.Config_Single_Time" href="#lyra_graphtool.configuration.Config_Single_Time">Config_Single_Time</a></code></h4>
<ul class="">
<li><code><a title="lyra_graphtool.configuration.Config_Single_Time.info" href="#lyra_graphtool.configuration.Config_Single_Time.info">info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lyra_graphtool.configuration.Configuration" href="#lyra_graphtool.configuration.Configuration">Configuration</a></code></h4>
<ul class="">
<li><code><a title="lyra_graphtool.configuration.Configuration.add_sched" href="#lyra_graphtool.configuration.Configuration.add_sched">add_sched</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.budget_feasible" href="#lyra_graphtool.configuration.Configuration.budget_feasible">budget_feasible</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.cost" href="#lyra_graphtool.configuration.Configuration.cost">cost</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.cost_sched" href="#lyra_graphtool.configuration.Configuration.cost_sched">cost_sched</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.feasible" href="#lyra_graphtool.configuration.Configuration.feasible">feasible</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_accessed_sites" href="#lyra_graphtool.configuration.Configuration.get_accessed_sites">get_accessed_sites</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_current_workers" href="#lyra_graphtool.configuration.Configuration.get_current_workers">get_current_workers</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_max_revenue" href="#lyra_graphtool.configuration.Configuration.get_max_revenue">get_max_revenue</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_sched_path_length" href="#lyra_graphtool.configuration.Configuration.get_sched_path_length">get_sched_path_length</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_vertices_start" href="#lyra_graphtool.configuration.Configuration.get_vertices_start">get_vertices_start</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.get_worker" href="#lyra_graphtool.configuration.Configuration.get_worker">get_worker</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.is_empty" href="#lyra_graphtool.configuration.Configuration.is_empty">is_empty</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.load_from_json" href="#lyra_graphtool.configuration.Configuration.load_from_json">load_from_json</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.revenue" href="#lyra_graphtool.configuration.Configuration.revenue">revenue</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.save" href="#lyra_graphtool.configuration.Configuration.save">save</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.save_to_json" href="#lyra_graphtool.configuration.Configuration.save_to_json">save_to_json</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_all_feasible_access_sites" href="#lyra_graphtool.configuration.Configuration.sched_all_feasible_access_sites">sched_all_feasible_access_sites</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_all_feasible_space" href="#lyra_graphtool.configuration.Configuration.sched_all_feasible_space">sched_all_feasible_space</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_feasible_access_sites" href="#lyra_graphtool.configuration.Configuration.sched_feasible_access_sites">sched_feasible_access_sites</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_feasible_space" href="#lyra_graphtool.configuration.Configuration.sched_feasible_space">sched_feasible_space</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_info" href="#lyra_graphtool.configuration.Configuration.sched_info">sched_info</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.sched_revenue" href="#lyra_graphtool.configuration.Configuration.sched_revenue">sched_revenue</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.site_accessed" href="#lyra_graphtool.configuration.Configuration.site_accessed">site_accessed</a></code></li>
<li><code><a title="lyra_graphtool.configuration.Configuration.site_accessed_at_time" href="#lyra_graphtool.configuration.Configuration.site_accessed_at_time">site_accessed_at_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>